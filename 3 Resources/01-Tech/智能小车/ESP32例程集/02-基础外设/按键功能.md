---
title: 按键功能
status: active
priority: medium
tags: [esp32/examples, gpio, button]
aliases: [按键输入, 按键实验]
created: 2026-02-19
modified: 2026-02-19
source: https://www.yahboom.com/public/upload/upload-html/1706346744/%E6%8C%89%E9%94%AE%E5%8A%9F%E8%83%BD.html
related:
  - [[MicroROS机器人控制板]]
  - [[点亮LED灯]]
---

# 按键功能

> 读取microROS控制板上的按键状态，打印ESP32S3芯片组空闲的内存容量。

---

## 📋 目录

- [实验目的](#一实验目的)
- [硬件连接](#二硬件连接)
- [核心代码解析](#三核心代码解析)
- [编译下载烧录固件](#四编译下载烧录固件)
- [实验效果](#五实验效果)

---

## 一、实验目的

读取microROS控制板上的按键状态，打印ESP32S3芯片组空闲的内存容量。

---

## 二、硬件连接

如下图所示，按键为板载元器件，所以不需要外接其他设备，只需要把type-C数据线连接电脑与microROS控制板作为烧录固件功能即可。

![image-20240110114106385](https://www.yahboom.com/public/upload/upload-html/1706346744/image-20240110114106385.png)

microROS控制板有两个boot按键和一个自定义功能按键，boot按键搭配reset复位按键可以让ESP32手动进入烧录模式，在开机完成后，boot按键也可以作为自定义功能按键来使用。

---

## 三、核心代码解析

程序源码对应的虚拟机路径为：

```
~/esp/Samples/esp32_samples/key
```

### 初始化KEY外设

其中KEY_GPIO_BOOT0对应硬件电路的GPIO0，KEY_GPIO_USER1对应硬件电路的GPIO42，GPIO模式设置为上拉输入模式。

```c
void Key_Init(void)
{
    // zero-initialize the config structure.
    gpio_config_t io_conf = {};

    // disable interrupt 禁用中断
    io_conf.intr_type = GPIO_INTR_DISABLE;

    // set as input mode 设置为输入模式
    io_conf.mode = GPIO_MODE_INPUT;

    // bit mask of the pins that you want to set 引脚编号设置
    io_conf.pin_bit_mask = ((1ULL<<KEY_GPIO_BOOT0)|(1ULL<<KEY_GPIO_USER1));

    // disable pull-down mode 禁用下拉
    io_conf.pull_down_en = 0;

    // enable pull-up mode 使能上拉
    io_conf.pull_up_en = 1;

    // configure GPIO with the given settings 配置GPIO口
    gpio_config(&io_conf);
}
```

### 判断按键是否被按下

以按键Key1为例来分析按键过程。如果被按下返回KEY_STATE_PRESS，松开状态返回KEY_STATE_RELEASE。

```c
static uint8_t Key1_is_Pressed(void)
{
    uint8_t key_state = KEY_STATE_RELEASE;

    if (!gpio_get_level(KEY_GPIO_USER1))
    {
        key_state = KEY_STATE_PRESS;
    }

    return key_state;
}
```

### 非阻塞式读取按键状态

软件防抖，需每10毫秒调用一次，每次按键按下返回一次KEY_STATE_PRESS。

```c
uint8_t Key1_Read_State(void)
{
    static uint16_t key_state = 0;

    if (Key1_is_Pressed() == KEY_STATE_PRESS)
    {
        if (key_state < 3)
        {
            key_state++;
        }
    }
    else
    {
        key_state = 0;
    }

    if (key_state == 2)
    {
        return KEY_STATE_PRESS;
    }

    return KEY_STATE_RELEASE;
}
```

在app_main里调用Key_Init函数初始化按键，并在循环中（每10毫秒）读取按键Key0和按键Key1的状态，当按下按键时打印按键按下提示，并打印当前空闲的内存容量。

```c
Key_Init();

while (1)
{
    if (Key0_Read_State() == KEY_STATE_PRESS)
    {
        ESP_LOGI(TAG, "KEY 0 PRESS");
        ESP_LOGI(TAG, "free internal heap size = %ld", esp_get_free_internal_heap_size());
    }

    if (Key1_Read_State() == KEY_STATE_PRESS)
    {
        ESP_LOGI(TAG, "KEY 1 PRESS");
        printf("free heap size = %ld\r\n", esp_get_free_heap_size());
    }

    vTaskDelay(pdMS_TO_TICKS(10));
}
```

---

## 四、编译下载烧录固件

使用Type-C数据线连接虚拟机/电脑与microROS控制板，如果系统弹窗选择连接到虚拟机上。

激活ESP-IDF开发环境，注意每次打开新终端都需要先激活ESP-IDF开发环境才可以编译固件。

```bash
source ~/esp/esp-idf/export.sh
```

进入项目目录

```bash
cd ~/esp/Samples/esp32_samples/key
```

编译、烧录、打开串口模拟器

```bash
idf.py build flash monitor
```

如果需要退出串口模拟器，请按**Ctrl+]**。

---

## 五、实验效果

串口模拟器打印"hello yahboom"欢迎词，当我们按下boot按键Key0时，串口模拟器会打印"KEY 0 PRESS"并且显示当前内部空闲内存容量。当我们按下自定义按键Key1时，串口模拟器会打印"KEY 1 PRESS"并且显示当前空闲内存容量。

---

## 🔗 相关文档

- [[点亮LED灯]] - LED控制实验
- [[ESP32开发基础]] - ESP32基础教程
