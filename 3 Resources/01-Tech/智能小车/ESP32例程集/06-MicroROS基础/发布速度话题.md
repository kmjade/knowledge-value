---
title: 发布速度话题
status: active
priority: medium
tags: [esp32/examples, microros/publisher]
aliases: [发布速度话题, odom话题发布]
created: 2026-02-19
modified: 2026-02-19
source: https://www.yahboom.com/public/upload/upload-html/1706347420/发布速度话题.html
related:
  - [[MicroROS机器人控制板]]
  - [[发布话题]]
  - [[订阅速度控制话题]]
---

# 发布速度话题

> 学习ESP32-microROS组件，接入ROS2环境，发布机器人小车的odom速度话题。

---

## 目录

- [实验目的](#一实验目的)
- [硬件连接](#二硬件连接)
- [核心代码解析](#三核心代码解析)
- [编译下载烧录固件](#四编译下载烧录固件)
- [实验效果](#五实验效果)

---

## 一、实验目的

学习ESP32-microROS组件，接入ROS2环境，发布机器人小车的odom速度话题。

---

## 二、硬件连接

如下图所示，microROS控制板集成了ESP32-S3-WROOM核心模组，自带无线WiFi功能，ESP32-S3核心模组需要连接天线，再将四路电机连接到电机接口上，还需要把type-C数据线连接电脑与microROS控制板作为烧录固件功能。

![image-20240117174957846](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240117174957846.png)

四路电机接口分别对应名称为:左前轮->Motor1，左后轮->Motor2，右前轮->Motor3，右后轮->Motor4。

![image-20240111155522592](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240111155522592.png)

电机接口线序，在microROS控制板背面有详细线序丝印，这里以Motor1为例，M1+和M1-是控制电机转动的接口，GND和VCC是编码器的供电电路，H1A和H1B为编码器脉冲检测引脚。

![image-20240111160116671](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240111160116671.png)

注意：如果是使用亚博智能配套的310电机和电机线，白色线壳端连接到microROS控制板上的接口，黑色线壳端连接到310电机接口。

---

## 三、核心代码解析

程序源码对应的虚拟机路径为：

```
~/esp/Samples/microros_samples/odom_publisher
```

在twist_subscriber订阅速度功能的基础上，增加发布odom速度话题的功能。

![image-20240117181909132](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240117181909132.png)

初始化发布速度的odom信息，frame_id设置为"odom_frame"，child_frame_id设置为"base_footprint"，然后根据ROS_NAMESPACE是否为空来决定是否加ROS_NAMESPACE前缀。

```c
void odom_ros_init(void)
{
   char* content_frame_id = "odom_frame";
   char* content_child_frame_id = "base_footprint";

   int len_namespace = strlen(ROS_NAMESPACE);
   int len_frame_id_max = len_namespace + strlen(content_frame_id) + 2;
   int len_child_frame_id_max = len_namespace + strlen(content_child_frame_id) + 2;

   char* frame_id = malloc(len_frame_id_max);
   char* child_frame_id = malloc(len_child_frame_id_max);

   if (len_namespace == 0)
   {
       // ROS命名空间为空字符
       // The ROS namespace is empty characters
       sprintf(frame_id, "%s", content_frame_id);
       sprintf(child_frame_id, "%s", content_child_frame_id);
   }
   else
   {
       // 拼接命名空间和frame id
       // Concatenate the namespace and frame id
       sprintf(frame_id, "%s/%s", ROS_NAMESPACE, content_frame_id);
       sprintf(child_frame_id, "%s/%s", ROS_NAMESPACE, content_child_frame_id);
   }

   msg_odom.header.frame_id = micro_ros_string_utilities_set(msg_odom.header.frame_id, frame_id);
   msg_odom.child_frame_id = micro_ros_string_utilities_set(msg_odom.child_frame_id, child_frame_id);

   free(frame_id);
   free(child_frame_id);
}
```

从IDF配置工具里获取要连接的WiFi名称和密码。

```c
#define ESP_WIFI_SSID     CONFIG_ESP_WIFI_SSID
#define ESP_WIFI_PASS     CONFIG_ESP_WIFI_PASSWORD
#define ESP_MAXIMUM_RETRY  CONFIG_ESP_MAXIMUM_RETRY
```

`uros_network_interface_initialize`函数会根据IDF中的WiFi配置来连接WiFi热点。

```c
ESP_ERROR_CHECK(uros_network_interface_initialize());
```

再从IDF配置工具里获取ROS_NAMESPACE、ROS_DOMAIN_ID、ROS_AGENT_IP和ROS_AGENT_PORT。

```c
#define ROS_NAMESPACE     CONFIG_MICRO_ROS_NAMESPACE
#define ROS_DOMAIN_ID    CONFIG_MICRO_ROS_DOMAIN_ID
#define ROS_AGENT_IP     CONFIG_MICRO_ROS_AGENT_IP
#define ROS_AGENT_PORT   CONFIG_MICRO_ROS_AGENT_PORT
```

初始化microROS的配置，其中ROS_DOMAIN_ID，ROS_AGENT_IP和ROS_AGENT_PORT根据实际需求在IDF配置工具中修改。

```c
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    // 创建rcl初始化选项
    // Create init_options.
    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();

    RCCHECK(rcl_init_options_init(&init_options, allocator));

    // 修改ROS域ID
    // change ros domain id
    RCCHECK(rcl_init_options_set_domain_id(&init_options, ROS_DOMAIN_ID));

    // 初始化rmw选项
    // Initialize the rmw options
    rmw_init_options_t *rmw_options = rcl_init_options_get_rmw_init_options(&init_options);

    // 设置静态代理IP和端口
    // Setup static agent IP and port
    RCCHECK(rmw_uros_options_set_udp_address(ROS_AGENT_IP, ROS_AGENT_PORT, rmw_options));
```

尝试连接代理，连接成功才进入下一步，如果连接代理不成功则一直处于连接状态。

```c
   while (1)
   {
       ESP_LOGI(TAG, "Connecting agent: %s:%s", ROS_AGENT_IP, ROS_AGENT_PORT);
       state_agent = rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator);

       if (state_agent == ESP_OK)
       {
           ESP_LOGI(TAG, "Connected agent: %s:%s", ROS_AGENT_IP, ROS_AGENT_PORT);
           break;
       }
       vTaskDelay(pdMS_TO_TICKS(500));
   }
```

创建节点"odom_publisher"，其中ROS_NAMESPACE默认为空，可根据实际在IDF配置工具中修改。

```c
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "odom_publisher", ROS_NAMESPACE, &support));
```

创建发布者"odom_raw"，需要指定发布者的信息为nav_msgs/msg/Odometry类型。

```c
   RCCHECK(rclc_publisher_init_default(
        &publisher_odom,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(nav_msgs, msg, Odometry),
        "odom_raw"));
```

创建发布者的定时器，发布频率为20HZ。

```c
   const unsigned int timer_timeout = 50;
   RCCHECK(rclc_timer_init_default(
        &timer_odom,
        &support,
        RCL_MS_TO_NS(timer_timeout),
        timer_odom_callback));
```

创建执行者，其中三个参数为执行者控制的数量，要大于或等于添加到执行者的订阅者和发布者数量。并添加发布者的定时器到执行者。

```c
   rclc_executor_t executor;
   int handle_num = 2;
   RCCHECK(rclc_executor_init(&executor, &support.context, handle_num, &allocator));
   RCCHECK(rclc_executor_add_timer(&executor, &timer_odom));
   RCCHECK(rclc_executor_add_subscription(
        &executor,
        &twist_subscriber,
        &twist_msg,
        &twist_Callback,
        ON_NEW_DATA));
```

odom的定时器回调函数主要功能是更新odom数据并且将数据发送出去。

```c
void timer_odom_callback(rcl_timer_t *timer, int64_t last_call_time)
{
   RCLC_UNUSED(last_call_time);

   if (timer != NULL)
   {
       struct timespec time_stamp = get_timespec();
       unsigned long now = get_millisecond();
       float vel_dt = (now - prev_odom_update) / 1000.0;
       prev_odom_update = now;

       Motion_Get_Speed(&car_motion);
       odom_update(
           vel_dt,
           car_motion.Vx,
           car_motion.Vy,
           car_motion.Wz);

       msg_odom.header.stamp.sec = time_stamp.tv_sec;
       msg_odom.header.stamp.nanosec = time_stamp.tv_nsec;
       RCSOFTCHECK(rcl_publish(&publisher_odom, &msg_odom, NULL));
   }
}
```

从机器人小车读取的速度，并且根据小车速度更新odom信息。

```c
void odom_update(float vel_dt, float linear_vel_x, float linear_vel_y, float angular_vel_z)
{
   float delta_heading = angular_vel_z * vel_dt; // radians
   float cos_h = cos(heading_);
   float sin_h = sin(heading_);
   float delta_x = (linear_vel_x * cos_h - linear_vel_y * sin_h) * vel_dt; // m
   float delta_y = (linear_vel_x * sin_h + linear_vel_y * cos_h) * vel_dt; // m

   // calculate current position of the robot
   x_pos_ += delta_x;
   y_pos_ += delta_y;
   heading_ += delta_heading;

   // calculate robot's heading in quaternion angle
   // ROS has a function to calculate yaw in quaternion angle
   float q[4];
   odom_euler_to_quat(0, 0, heading_, q);

   // robot's position in x,y, and z
   msg_odom.pose.pose.position.x = x_pos_;
   msg_odom.pose.pose.position.y = y_pos_;
   msg_odom.pose.pose.position.z = 0.0;

   // robot's heading in quaternion
   msg_odom.pose.pose.orientation.x = (double)q[1];
   msg_odom.pose.pose.orientation.y = (double)q[2];
   msg_odom.pose.pose.orientation.z = (double)q[3];
   msg_odom.pose.pose.orientation.w = (double)q[0];

   msg_odom.pose.covariance[0] = 0.001;
   msg_odom.pose.covariance[7] = 0.001;
   msg_odom.pose.covariance[35] = 0.001;

   // linear speed from encoders
   msg_odom.twist.twist.linear.x = linear_vel_x;
   msg_odom.twist.twist.linear.y = linear_vel_y;
   msg_odom.twist.twist.linear.z = 0.0;

   // angular speed from encoders
   msg_odom.twist.twist.angular.x = 0.0;
   msg_odom.twist.twist.angular.y = 0.0;
   msg_odom.twist.twist.angular.z = angular_vel_z;

   msg_odom.twist.covariance[0] = 0.0001;
   msg_odom.twist.covariance[7] = 0.0001;
   msg_odom.twist.covariance[35] = 0.0001;
}
```

在循环中调用rclc_executor_spin_some来让microros正常工作起来。

```c
    while (1)
   {
       rclc_executor_spin_some(&executor, RCL_MS_TO_NS(100));
       usleep(1000);
   }
```

---

## 四、编译下载烧录固件

使用Type-C数据线连接虚拟机/电脑与microROS控制板，如果系统弹窗选择连接到虚拟机上。

激活ESP-IDF开发环境，注意每次打开新终端都需要先激活ESP-IDF开发环境才可以编译固件。

```bash
source ~/esp/esp-idf/export.sh
```

进入项目目录：

```bash
cd ~/esp/Samples/microros_samples/odom_publisher
```

打开ESP-IDF的配置工具。

```bash
idf.py menuconfig
```

打开micro-ROS Settings，在micro-ROS Agent IP填入代理主机的IP地址，在micro-ROS Agent Port填入代理主机的端口号。

![image-20240116194035834](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240116194035834.png)

依次打开micro-ROS Settings->WiFi Configuration，在WiFi SSID和WiFi Password这两栏填入自家的WiFi名称和密码。

![image-20240116193354397](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240116193354397.png)

打开micro-ROS example-app settings，Ros domain id of the micro-ROS默认为20，如果局域网内有多用户同时使用的情况，可修改参数以避免冲突。Ros namespace of the micro-ROS默认为空，正常情况下可以不修改，如果修改非空字符（10个字符以内），则会在节点和话题前加上namespace参数。

![image-20240116195328563](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240116195328563.png)

修改后按S保存，再按Q退出配置工具。

编译、烧录、打开串口模拟器。

```bash
idf.py build flash monitor
```

如果需要退出串口模拟器，请按**Ctrl+]**。

---

## 五、实验效果

开机后，ESP32尝试连接WiFi热点，再尝试连接代理IP和端口。

如果虚拟机/电脑终端没有打开代理，请输入以下命令开启代理，如果代理已经启动，则无需再启动代理。

```bash
docker run -it --rm -v /dev:/dev -v /dev/shm:/dev/shm --privileged --net=host microros/micro-ros-agent:humble udp4 --port 8090 -v4
```

![image-20240117151035412](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240117151035412.png)

连接成功后创建一个节点、一个发布者和一个订阅者。

![image-20240117113138240](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240117113138240.png)

此时可以在虚拟机/电脑另开一个终端，查看/odom_publisher节点。

```bash
ros2 node list
ros2 node info /odom_publisher
```

![image-20240118111650355](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240118111650355.png)

向/cmd_vel话题发布数据，控制机器人小车以0.5m/s向前行走。

```bash
ros2 topic pub --once /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}"
```

订阅/odom_raw话题的数据：

```bash
ros2 topic echo /odom_raw
```

按Ctrl+C结束命令。

![image-20240118112009255](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240118112009255.png)

![image-20240118113344508](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240118113344508.png)

查看/odom_raw话题的频率，大约为20hz则为正常。

```bash
ros2 topic hz /odom_raw
```

按Ctrl+C结束命令。

![image-20240118112158523](https://www.yahboom.com/public/upload/upload-html/1706347420/image-20240118112158523.png)

向/cmd_vel话题发布数据，控制机器人小车停止。

```bash
ros2 topic pub --once /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}"
```

---

## 相关文档

- [[订阅速度控制话题]] - 速度控制订阅
- [[发布IMU数据话题]] - IMU数据发布
- [[机器人运动学分析与理论]] - 运动学原理
