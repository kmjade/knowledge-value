---
title: è‡ªå‹•åŒ–å ´æ™¯æ¡ˆä¾‹
status: active
priority: high
tags: [clawdbot, automation, cases, examples]
aliases: [è‡ªå‹•åŒ–æ¡ˆä¾‹, å®æˆ˜æ¡ˆä¾‹]
created: 2026-01-31
modified: 2026-01-31
---

# è‡ªå‹•åŒ–å ´æ™¯æ¡ˆä¾‹

> æœ¬æ–‡æª”æ”¶é›†äº† ClawdBot çš„å®é™…æ‡‰ç”¨ç¨‹å¼å ´æ™¯å’Œå®Œæ•´å¯¦ç¾æ¡ˆä¾‹ï¼Œå¸®åŠ©æ‚¨å¿«é€Ÿç†è§£å¦‚ä½•è§£æ±ºå®é™…å•é¡Œã€‚

## ğŸ“‹ ç›®éŒ„

- [ç”µå•†è‡ªå‹•åŒ–](#ç”µå•†è‡ªå‹•åŒ–)
# åˆ†æ
- [å®¢æˆ·æœåŠ¡è‡ªå‹•åŒ–](#å®¢æˆ·æœåŠ¡è‡ªå‹•åŒ–)
# ç®¡ç†
- [æ•¸æ“šå‚™ä»½ä¸åŒæ­¥](#æ•¸æ“šå‚™ä»½ä¸åŒæ­¥)
- [è´¢åŠ¡æŠ¥è¡¨è‡ªå‹•åŒ–](#è´¢åŠ¡æŠ¥è¡¨è‡ªå‹•åŒ–)
# ç®¡ç†

---

## ç”µå•†è‡ªå‹•åŒ–

### æ¡ˆä¾‹1ï¼šç«å“ä»·æ ¼ç›£æ§

**å ´æ™¯æè¿°ï¼š**
è‡ªå‹•ç›£æ§ç«äº‰å¯¹æ‰‹çš„å•†å“ä»·æ ¼å˜åŒ–ï¼Œå½“ä»·æ ¼ä½äºè®¾å®šé˜ˆå€¼æ—¶ç™¼é€å‘Šè­¦ã€‚

```python
# examples/ecommerce/price_monitor.py
from clawdbot import Clawdbot, Task
import asyncio
from datetime import datetime

class PriceMonitor:
    def __init__(self, bot: Clawdbot):
        self.bot = bot
        self.products = [
            {
                "id": "P001",
                "name": "é«˜ç«¯è€³æœº",
                "competitor_url": "https://competitor.com/product/earbuds",
                "threshold": 299.0  # ä½äºæ­¤ä»·æ ¼å‘Šè­¦
            },
            {
                "id": "P002",
                "name": "æ™ºèƒ½æ‰‹è¡¨",
                "competitor_url": "https://competitor.com/product/watch",
                "threshold": 599.0
            }
        ]

    async def monitor_prices(self):
        """ç›£æ§æ‰€æœ‰äº§å“ä»·æ ¼"""
        results = []

        for product in self.products:
            try:
                # æŠ“å–ç«äº‰å¯¹æ‰‹ä»·æ ¼
                price = await self.scrape_competitor_price(product["competitor_url"])

                result = {
                    "product_id": product["id"],
                    "product_name": product["name"],
                    "competitor_price": price,
                    "threshold": product["threshold"],
                    "is_below_threshold": price < product["threshold"],
                    "timestamp": datetime.now().isoformat()
                }

                results.append(result)

                # å¦‚æœä»·æ ¼ä½äºé˜ˆå€¼ï¼Œç™¼é€å‘Šè­¦
                if price < product["threshold"]:
                    await self.send_price_alert(result)

            except Exception as e:
                print(f"ç›£æ§å¤±è´¥ {product['name']}: {e}")

        return results

    async def scrape_competitor_price(self, url: str) -> float:
        """æŠ“å–ç«äº‰å¯¹æ‰‹ä»·æ ¼"""
        task = Task(
            type="web_scrape",
            params={
                "url": url,
                "selectors": {
                    "price": ".product-price",
                    "currency": ".currency-symbol"
                },
                "timeout": 30
            }
        )

        result = await self.bot.execute(task)

        # æå–ä»·æ ¼æ•°å€¼
        price_text = result.data["price"]
        price = float(price_text.replace("Â¥", "").replace(",", ""))

        return price

    async def send_price_alert(self, price_info: dict):
        """ç™¼é€ä»·æ ¼å‘Šè­¦"""
        alert_task = Task(
            type="send_email",
            params={
                "to": ["pricing@company.com", "marketing@company.com"],
                "subject": f"ğŸš¨ ä»·æ ¼å‘Šè­¦: {price_info['product_name']}",
                "body": f"""
                ç«å“ä»·æ ¼ç›‘æµ‹å‘Šè­¦

                äº§å“: {price_info['product_name']}
                å½“å‰ç«å“ä»·æ ¼: Â¥{price_info['competitor_price']}
                è®¾å®šé˜ˆå€¼: Â¥{price_info['threshold']}
                ä»·æ ¼å·®: Â¥{price_info['threshold'] - price_info['competitor_price']}

                ç›‘æµ‹æ™‚é–“: {price_info['timestamp']}

                è¯·åŠæ—¶è©•ä¼°æ˜¯å¦éœ€è¦è°ƒæ•´ä»·æ ¼ç­–ç•¥ï¼
                """,
                "priority": "high"
            }
        )

        await self.bot.execute(alert_task)

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    bot = Clawdbot(config="config.yaml")
    monitor = PriceMonitor(bot)

    # æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡ç›£æ§
    while True:
        results = await monitor.monitor_prices()
        print(f"ç›£æ§å®Œæˆï¼Œæª¢æŸ¥äº† {len(results)} ä¸ªäº§å“")

        # ç­‰å¾…1å°æ—¶
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
```

# å·¥ä½œæµ

```yaml
# workflows/price_monitoring.yml
name: ç«å“ä»·æ ¼ç›£æ§
schedule:
  cron: "0 * * * *"  # æ¯å°æ—¶
  timezone: "Asia/Shanghai"

steps:
  - name: è·å–äº§å“åˆ—è¡¨
    type: database_query
    params:
      query: "SELECT * FROM products WHERE monitoring_enabled = true"

  - name: æŠ“å–ç«å“ä»·æ ¼
    type: parallel_scrape
    params:
      max_concurrency: 5
      timeout_per_task: 30

  - name: å°æ¯”ä»·æ ¼
    type: transform
    params:
      script: "compare_prices.js"

  - name: ç™¼é€å‘Šè­¦
    type: conditional_action
    params:
      condition: "price < threshold"
      action: "send_email"
```

---

### æ¡ˆä¾‹2ï¼šè¨‚å–®è‡ªå‹•è™•ç†

```python
# examples/ecommerce/order_processing.py
from clawdbot import Clawdbot, Task

class OrderProcessor:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def process_new_orders(self):
        """è™•ç†æ–°è¨‚å–®"""

        # 1. è·å–å¾…è™•ç†è¨‚å–®
        orders = await self.fetch_pending_orders()

        for order in orders:
            try:
                # 2. é©—è­‰åº“å­˜
                stock_available = await self.check_inventory(order["items"])

                if stock_available:
                    # 3. æ‰£å‡åº“å­˜
                    await self.deduct_inventory(order["items"])

                    # 4. ç”Ÿæˆå‡ºè²¨å•
                    shipping_info = await self.create_shipping_order(order)

                    # 5. ç™¼é€ç¢ºèªé›»å­éƒµä»¶
                    await self.send_order_confirmation(order, shipping_info)

# æ›´æ–°
                    await self.update_order_status(order["id"], "processing")

                else:
                    # åº“å­˜ä¸è¶³
                    await self.handle_out_of_stock(order)

            except Exception as e:
                await self.handle_processing_error(order, e)

    async def fetch_pending_orders(self):
        """è·å–å¾…è™•ç†è¨‚å–®"""
        task = Task(
            type="api_call",
            params={
                "method": "GET",
                "url": "/api/orders",
                "params": {
                    "status": "pending",
                    "limit": 50
                }
            }
        )

        result = await self.bot.execute(task)
        return result.data

    async def check_inventory(self, items: list) -> bool:
        """æª¢æŸ¥åº“å­˜"""
        for item in items:
            stock = await self.get_stock(item["product_id"])
            if stock < item["quantity"]:
                return False
        return True

    async def create_shipping_order(self, order: dict) -> dict:
        """å‰µå»ºå‡ºè²¨å•"""
        task = Task(
            type="form_submit",
            params={
                "url": "https://shipping.partner.com/api/create",
                "form_data": {
                    "recipient_name": order["customer_name"],
                    "recipient_address": order["shipping_address"],
                    "recipient_phone": order["phone"],
                    "packages": order["items"],
                    "service_type": "standard"
                }
            }
        )

        result = await self.bot.execute(task)
        return result.data

    async def send_order_confirmation(self, order: dict, shipping_info: dict):
        """ç™¼é€è¨‚å–®ç¢ºèªé›»å­éƒµä»¶"""
        task = Task(
            type="send_email",
            params={
                "to": [order["customer_email"]],
                "template": "order_confirmation",
                "data": {
                    "order_id": order["id"],
                    "items": order["items"],
                    "total": order["total"],
                    "shipping_tracking": shipping_info["tracking_number"]
                }
            }
        )

        await self.bot.execute(task)
```

---

# åˆ†æ

# åˆ†æ

```python
# examples/analytics/social_media_analyzer.py
from clawdbot import Clawdbot, Task
import pandas as pd
from datetime import datetime, timedelta

class SocialMediaAnalyzer:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def daily_analysis(self):
# åˆ†æ

        # 1. é‡‡é›†æ•¸æ“š
        data = await self.collect_data()

        # 2. æ•¸æ“šæ¸…æ´—
        clean_data = await self.clean_data(data)

        # 3. ç”Ÿæˆå ±å‘Š
        report = await self.generate_report(clean_data)

        # 4. ç™¼é€å ±å‘Š
        await self.send_report(report)

    async def collect_data(self):
        """é‡‡é›†å¤šå¹³å°æ•¸æ“š"""
        platforms = ["twitter", "weibo", "wechat"]
        all_data = []

        for platform in platforms:
            # é‡‡é›†æ•¸æ“š
            task = Task(
                type="api_call",
                params={
                    "method": "GET",
                    "url": f"/api/{platform}/analytics",
                    "params": {
                        "start_date": (datetime.now() - timedelta(days=1)).isoformat(),
                        "end_date": datetime.now().isoformat()
                    }
                }
            )

            result = await self.bot.execute(task)
            all_data.extend(result.data)

        return all_data

    async def generate_report(self, data: list):
# åˆ†æ

        # è½¬æ¢ä¸º DataFrame
        df = pd.DataFrame(data)

        # è¨ˆç®—é—œéµæŒ‡æ ‡
        metrics = {
            "total_posts": len(df),
            "total_engagement": df["engagement"].sum(),
            "avg_engagement_rate": df["engagement_rate"].mean(),
            "top_posts": df.nlargest(5, "engagement")[["platform", "content", "engagement"]].to_dict("records"),
            "platform_distribution": df.groupby("platform")["engagement"].sum().to_dict()
        }

        # ç”Ÿæˆåœ–è¡¨
        charts = await self.generate_charts(df)

        return {
            "date": datetime.now().strftime("%Y-%m-%d"),
            "metrics": metrics,
            "charts": charts,
            "insights": await self.generate_insights(metrics)
        }

    async def generate_insights(self, metrics: dict) -> list:
        """ç”Ÿæˆæ´å¯Ÿ"""
        insights = []

        # åŸºäºæŒ‡æ ‡çš„æ´å¯Ÿ
        if metrics["avg_engagement_rate"] > 0.05:
            insights.append("äº’åŠ¨ç‡è¡¨ç°ä¼˜å¼‚ï¼Œå…§å®¹ç­–ç•¥æœ‰æ•ˆ")

        best_platform = max(metrics["platform_distribution"], key=metrics["platform_distribution"].get)
        insights.append(f"{best_platform} å¹³å°è¡¨ç°æœ€ä½³ï¼Œå»ºè­°å¢åŠ æŠ•å…¥")

        return insights

    async def send_report(self, report: dict):
        """ç™¼é€å ±å‘Š"""
        task = Task(
            type="send_email",
            params={
                "to": ["analytics@company.com", "marketing@company.com"],
                "subject": f"ğŸ“Š ç¤¾äº¤åª’ä½“æ•¸æ“šæ—¥æŠ¥ - {report['date']}",
                "body": f"""
# åˆ†æ

                ğŸ“ˆ æ ¸å¿ƒæŒ‡æ ‡ï¼š
                - æ€»ç™¼ä½ˆæ•°ï¼š{report['metrics']['total_posts']}
                - æ€»äº’åŠ¨é‡ï¼š{report['metrics']['total_engagement']}
                - å¹³å‡äº’åŠ¨ç‡ï¼š{report['metrics']['avg_engagement_rate']:.2%}

                ğŸ”¥ çƒ­é—¨å…§å®¹ï¼š
                {self.format_top_posts(report['metrics']['top_posts'])}

                ğŸ’¡ æ•¸æ“šæ´å¯Ÿï¼š
                {chr(10).join(f'- {insight}' for insight in report['insights'])}
                """,
                "attachments": report["charts"]
            }
        )

        await self.bot.execute(task)
```

---

## å®¢æˆ·æœåŠ¡è‡ªå‹•åŒ–

### æ¡ˆä¾‹4ï¼šæ™ºèƒ½å®¢æœå·¥å•åˆ†é…

```python
# examples/customer_service/ticket_routing.py
from clawdbot import Clawdbot, Task
import re

class TicketRouter:
    def __init__(self, bot: Clawdbot):
        self.bot = bot
        self.routing_rules = {
            "æŠ€è¡“æ”¯æŒ": [
# é…ç½®
            ],
            "è´¦å•å•é¡Œ": [
                r"è´¦å•|æ”¯ä»˜|å‘ç¥¨|é€€æ¬¾|æ‰£è´¹"
            ],
            "åŠŸèƒ½å»ºè­°": [
                r"å»ºè­°|å¸Œæœ›|æ–°å¢|æ”¹è¿›|éœ€æ±‚"
            ],
            "æŠ•è¨´": [
                r"æŠ•è¨´|ä¸æ»¡|ç³Ÿç³•|å¤±æœ›|æ…¢"
            ]
        }

    async def route_new_tickets(self):
        """åˆ†é…æ–°å·¥å•"""

        # è·å–æœªåˆ†é…çš„å·¥å•
        tickets = await self.fetch_unassigned_tickets()

        for ticket in tickets:
# åˆ†æ
            category = self.classify_ticket(ticket)

            # åˆ†é…ç»™å¯¹åº”åœ˜éšŠ
            team = self.get_team_for_category(category)

# æ›´æ–°
            await self.assign_ticket(ticket["id"], team, category)

            # é€šçŸ¥åœ˜éšŠ
            await self.notify_team(team, ticket)

    def classify_ticket(self, ticket: dict) -> str:
        """åˆ†é¡å·¥å•"""
        text = f"{ticket['subject']} {ticket['description']}"

        for category, patterns in self.routing_rules.items():
            for pattern in patterns:
                if re.search(pattern, text, re.IGNORECASE):
                    return category

        return "ä¸€èˆ¬å’¨è¯¢"

    def get_team_for_category(self, category: str) -> str:
        """è·å–è´Ÿè´£åœ˜éšŠ"""
        team_mapping = {
            "æŠ€è¡“æ”¯æŒ": "tech_support",
            "è´¦å•å•é¡Œ": "billing",
            "åŠŸèƒ½å»ºè­°": "product",
            "æŠ•è¨´": "escalation",
            "ä¸€èˆ¬å’¨è¯¢": "general_support"
        }

        return team_mapping.get(category, "general_support")

    async def assign_ticket(self, ticket_id: str, team: str, category: str):
        """åˆ†é…å·¥å•"""
        task = Task(
            type="api_call",
            params={
                "method": "PUT",
                "url": f"/api/tickets/{ticket_id}",
                "data": {
                    "assigned_team": team,
                    "category": category,
                    "status": "assigned"
                }
            }
        )

        await self.bot.execute(task)

    async def notify_team(self, team: str, ticket: dict):
        """é€šçŸ¥åœ˜éšŠ"""
        team_email = self.get_team_email(team)

        task = Task(
            type="send_email",
            params={
                "to": [team_email],
                "subject": f"ğŸ« æ–°å·¥å•åˆ†é…: {ticket['subject']}",
                "body": f"""
                æ–°å·¥å•å·²åˆ†é…åˆ°æ‚¨çš„åœ˜éšŠ

                å·¥å•ç¼–å·ï¼š{ticket['id']}
                ä¸»é¡Œï¼š{ticket['subject']}
                å„ªå…ˆç´šï¼š{ticket['priority']}
                æäº¤æ™‚é–“ï¼š{ticket['created_at']}

                æè¿°ï¼š
                {ticket['description']}

                è¯·åŠæ—¶è™•ç†ï¼
                """
            }
        )

        await self.bot.execute(task)
```

---

# ç®¡ç†

### æ¡ˆä¾‹5ï¼šå…§å®¹è‡ªå‹•ç™¼ä½ˆ

```python
# examples/social_media/auto_publisher.py
from clawdbot import Clawdbot, Task
from datetime import datetime, timedelta

class ContentPublisher:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def publish_scheduled_content(self):
        """ç™¼ä½ˆå®šæ—¶å…§å®¹"""

        # è·å–å¾…ç™¼ä½ˆå…§å®¹
        content = await self.fetch_scheduled_content()

        for item in content:
            if self.should_publish(item):
                try:
                    # ç™¼ä½ˆåˆ°å„ä¸ªå¹³å°
                    results = await self.publish_to_platforms(item)

                    # è¨˜éŒ„ç™¼ä½ˆçµæœ
                    await self.log_publication(item, results)

# æ›´æ–°
                    await self.mark_as_published(item["id"])

                except Exception as e:
                    await self.handle_publishing_error(item, e)

    async def publish_to_platforms(self, content: dict):
        """ç™¼ä½ˆåˆ°å¤šå€‹å¹³å°"""
        platforms = content.get("platforms", ["twitter", "weibo"])
        results = {}

        for platform in platforms:
            task = Task(
                type="social_media_post",
                params={
                    "platform": platform,
                    "content": self.format_content(platform, content),
                    "media": content.get("media", []),
                    "scheduled_at": content.get("scheduled_at")
                }
            )

            result = await self.bot.execute(task)
            results[platform] = {
                "success": result.success,
                "post_id": result.data.get("post_id"),
                "url": result.data.get("post_url")
            }

        return results

    def format_content(self, platform: str, content: dict) -> str:
        """æ ¼å¼åŒ–ä¸åŒå¹³å°çš„å…§å®¹"""
        text = content["text"]

        if platform == "twitter":
            # Twitter é™åˆ¶ 280 å­—ç¬¦
            if len(text) > 280:
                text = text[:277] + "..."
            # æ–°å¢è¯é¢˜æ¨™ç±¤
            text += " " + " ".join(content.get("hashtags", []))[:100]

        elif platform == "weibo":
            # å¾®åšé™åˆ¶ 140 å­—ï¼ˆä¸­æ–‡ï¼‰
            pass

        elif platform == "linkedin":
            # LinkedIn å¯ä»¥æ›´é•¿
            text = f"{text}\n\n{content.get('link', '')}"

        return text
```

---

## æ•¸æ“šå‚™ä»½ä¸åŒæ­¥

### æ¡ˆä¾‹6ï¼šè‡ªå‹•åŒ–æ•¸æ“šå‚™ä»½

```python
# examples/backup/auto_backup.py
from clawdbot import Clawdbot, Task
from datetime import datetime

class AutoBackup:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def perform_backup(self):
        """æ‰§è¡Œå‚™ä»½"""

        # 1. å‚™ä»½è³‡æ–™åº«
        db_backup = await self.backup_database()

        # 2. å‚™ä»½æª”æ¡ˆ
        file_backup = await self.backup_files()

        # 3. ä¸Šå‚³åˆ°é›²ç«¯å„²å­˜
        await self.upload_to_cloud(db_backup, file_backup)

        # 4. æ¸…ç†æ—§å‚™ä»½
        await self.cleanup_old_backups()

    async def backup_database(self) -> str:
        """å‚™ä»½è³‡æ–™åº«"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"backup/db_backup_{timestamp}.sql"

        task = Task(
            type="database_dump",
            params={
                "database": "production",
                "output_file": backup_file,
                "compression": "gzip"
            }
        )

        result = await self.bot.execute(task)
        return result.data["backup_file"]

    async def backup_files(self) -> str:
        """å‚™ä»½æª”æ¡ˆ"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"backup/files_backup_{timestamp}.tar.gz"

        task = Task(
            type="archive_files",
            params={
                "source_dir": "/app/data",
                "output_file": backup_file,
                "exclude": ["*.log", "*.tmp", "cache/*"]
            }
        )

        result = await self.bot.execute(task)
        return result.data["archive_file"]

    async def upload_to_cloud(self, db_backup: str, file_backup: str):
        """ä¸Šå‚³åˆ°é›²ç«¯å„²å­˜"""
        for backup_file in [db_backup, file_backup]:
            task = Task(
                type="cloud_upload",
                params={
                    "file": backup_file,
                    "bucket": "company-backups",
                    "path": f"daily/{datetime.now().strftime('%Y/%m/%d')}/{backup_file.split('/')[-1]}"
                }
            )

            await self.bot.execute(task)

    async def cleanup_old_backups(self):
        """æ¸…ç†æ—§å‚™ä»½ï¼ˆä¿ç•™æœ€è¿‘7å¤©ï¼‰"""
        task = Task(
            type="cloud_cleanup",
            params={
                "bucket": "company-backups",
                "pattern": "daily/**/*",
                "older_than_days": 7
            }
        )

        await self.bot.execute(task)
```

---

## è´¢åŠ¡æŠ¥è¡¨è‡ªå‹•åŒ–

### æ¡ˆä¾‹7ï¼šæœˆåº¦è´¢åŠ¡å ±å‘Šç”Ÿæˆ

```python
# examples/finance/monthly_report.py
from clawdbot import Clawdbot, Task
import pandas as pd
from datetime import datetime, timedelta

class MonthlyFinanceReport:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def generate_report(self, month: int, year: int):
        """ç”Ÿæˆæœˆåº¦å ±å‘Š"""

        # 1. æ”¶é›†è´¢åŠ¡æ•¸æ“š
        financial_data = await self.collect_financial_data(month, year)

        # 2. è¨ˆç®—è´¢åŠ¡æŒ‡æ ‡
        metrics = self.calculate_metrics(financial_data)

        # 3. ç”Ÿæˆåœ–è¡¨
        charts = await self.generate_charts(financial_data)

        # 4. ç”Ÿæˆ PDF å ±å‘Š
        pdf_file = await self.generate_pdf_report(metrics, charts)

        # 5. ç™¼é€å ±å‘Š
        await self.send_report(pdf_file, month, year)

    async def collect_financial_data(self, month: int, year: int):
        """æ”¶é›†è´¢åŠ¡æ•¸æ“š"""
        start_date = datetime(year, month, 1).isoformat()
        end_date = (datetime(year, month, 1) + timedelta(days=32)).replace(day=1).isoformat()

        # æ”¶å…¥æ•¸æ“š
        revenue_task = Task(
            type="database_query",
            params={
                "query": f"""
                    SELECT date, amount, category
                    FROM revenue
                    WHERE date >= '{start_date}' AND date < '{end_date}'
                """
            }
        )

        # æ”¯å‡ºæ•¸æ“š
        expense_task = Task(
            type="database_query",
            params={
                "query": f"""
                    SELECT date, amount, category
                    FROM expenses
                    WHERE date >= '{start_date}' AND date < '{end_date}'
                """
            }
        )

        # å¹¶è¡Œæ‰§è¡Œ
        revenue = await self.bot.execute(revenue_task)
        expenses = await self.bot.execute(expense_task)

        return {
            "revenue": revenue.data,
            "expenses": expenses.data
        }

    def calculate_metrics(self, data: dict) -> dict:
        """è¨ˆç®—è´¢åŠ¡æŒ‡æ ‡"""
        revenue_df = pd.DataFrame(data["revenue"])
        expense_df = pd.DataFrame(data["expenses"])

        total_revenue = revenue_df["amount"].sum()
        total_expenses = expense_df["amount"].sum()
        net_profit = total_revenue - total_expenses
        profit_margin = (net_profit / total_revenue) * 100 if total_revenue > 0 else 0

        revenue_by_category = revenue_df.groupby("category")["amount"].sum().to_dict()
        expense_by_category = expense_df.groupby("category")["amount"].sum().to_dict()

        return {
            "total_revenue": total_revenue,
            "total_expenses": total_expenses,
            "net_profit": net_profit,
            "profit_margin": profit_margin,
            "revenue_by_category": revenue_by_category,
            "expense_by_category": expense_by_category
        }
```

---

# ç®¡ç†

### æ¡ˆä¾‹8ï¼šå°ˆæ¡ˆè¿›åº¦è‡ªå‹•è·Ÿè¸ª

```python
# examples/project_management/progress_tracker.py
from clawdbot import Clawdbot, Task
from datetime import datetime, timedelta

class ProjectProgressTracker:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def track_progress(self):
        """è·Ÿè¸ªå°ˆæ¡ˆè¿›åº¦"""

        # è·å–æ‰€æœ‰æ´»è·ƒå°ˆæ¡ˆ
        projects = await self.fetch_active_projects()

        for project in projects:
            # è¨ˆç®—è¿›åº¦
            progress = await self.calculate_project_progress(project)

            # æª¢æŸ¥é‡Œç¨‹ç¢‘
            milestones = await self.check_milestones(project, progress)

            # æª¢æŸ¥é£é™©
            risks = await self.assess_risks(project, progress)

# æ›´æ–°
            if self.should_notify(project, progress, milestones, risks):
                await self.send_progress_update(project, progress, milestones, risks)

    async def calculate_project_progress(self, project: dict) -> dict:
        """è¨ˆç®—å°ˆæ¡ˆè¿›åº¦"""
        tasks = await self.fetch_project_tasks(project["id"])

        completed_tasks = [t for t in tasks if t["status"] == "completed"]
        total_tasks = len(tasks)

        progress_percentage = (len(completed_tasks) / total_tasks * 100) if total_tasks > 0 else 0

        # è¨ˆç®—é¢„ç®—ä½¿ç”¨
        spent = project.get("budget_spent", 0)
        total_budget = project.get("budget", 1)
        budget_usage = (spent / total_budget * 100) if total_budget > 0 else 0

        return {
            "percentage": progress_percentage,
            "completed_tasks": len(completed_tasks),
            "total_tasks": total_tasks,
            "budget_usage": budget_usage,
            "on_schedule": self.check_if_on_schedule(project, tasks)
        }

    async def check_milestones(self, project: dict, progress: dict) -> list:
        """æª¢æŸ¥é‡Œç¨‹ç¢‘"""
        milestones = await self.fetch_project_milestones(project["id"])
        completed_milestones = []

        for milestone in milestones:
            if progress["percentage"] >= milestone["percentage"] and not milestone["completed"]:
                completed_milestones.append(milestone)

        return completed_milestones

    async def assess_risks(self, project: dict, progress: dict) -> list:
        """è©•ä¼°å°ˆæ¡ˆé£é™©"""
        risks = []

        # è¿›åº¦å»¶é²é£é™©
        if not progress["on_schedule"]:
            risks.append({
                "type": "schedule_delay",
                "severity": "high",
                "description": "å°ˆæ¡ˆè¿›åº¦è½åäºè¨ˆåŠƒ"
            })

        # é¢„ç®—è¶…æ”¯é£é™©
        if progress["budget_usage"] > 90:
            risks.append({
                "type": "budget_overrun",
                "severity": "high" if progress["budget_usage"] > 100 else "medium",
                "description": f"é¢„ç®—å·²ä½¿ç”¨ {progress['budget_usage']:.1f}%"
            })

        # é€¾æœŸä»»å‹™é£é™©
        overdue_tasks = await self.get_overdue_tasks(project["id"])
        if overdue_tasks:
            risks.append({
                "type": "overdue_tasks",
                "severity": "medium",
                "description": f"{len(overdue_tasks)} ä¸ªä»»å‹™å·²é€¾æœŸ",
                "details": overdue_tasks
            })

        return risks

    async def send_progress_update(self, project: dict, progress: dict, milestones: list, risks: list):
# æ›´æ–°
        task = Task(
            type="send_email",
            params={
                "to": project["stakeholders"],
# æ›´æ–°
                "template": "project_progress",
                "data": {
                    "project_name": project["name"],
                    "progress": progress,
                    "milestones": milestones,
                    "risks": risks
                }
            }
        )

        await self.bot.execute(task)
```

---

## ç¸½çµ

### å ´æ™¯åˆ†é¡çŸ©é˜µ

| å ´æ™¯ç±»å‹ | å¤æ‚åº¦ | å¸¸ç”¨çµ„ä»¶ | å…¸å‹ä»»å‹™ |
|---------|-------|---------|---------|
| ç”µå•†è‡ªå‹•åŒ– | ä¸­ç­‰ | ç¶²é æŠ“å–ã€APIèª¿ç”¨ã€é›»å­éƒµä»¶ | ä»·æ ¼ç›£æ§ã€è¨‚å–®è™•ç† |
# åˆ†æ
| å®¢æˆ·æœåŠ¡ | ä¸­ç­‰ | è¡¨å•è™•ç†ã€è§„åˆ™å¼•æ“ã€é€šçŸ¥ | å·¥å•åˆ†é…ã€è‡ªå‹•å›è¦† |
| ç¤¾äº¤åª’ä½“ | ä¸­ç­‰ | APIèª¿ç”¨ã€å…§å®¹ç™¼ä½ˆã€å®šæ—¶ä»»å‹™ | å…§å®¹ç™¼ä½ˆã€æ•¸æ“šé‡‡é›† |
| å‚™ä»½åŒæ­¥ | è¾ƒä½ | è³‡æ–™åº«æ“ä½œã€æª”æ¡ˆæ“ä½œã€é›²ç«¯å„²å­˜ | å®šæ—¶å‚™ä»½ã€æ•¸æ“šåŒæ­¥ |
# åˆ†æ
# ç®¡ç†

### é–‹ç™¼å»ºè­°

1. **ä»å°åˆ°å¤§**ï¼šå…ˆå¯¦ç¾æ ¸å¿ƒåŠŸèƒ½ï¼Œå†é€æ­¥å®Œå–„
2. **æ¨¡å—åŒ–è¨­è¨ˆ**ï¼šå°†å¤æ‚ä»»å‹™åˆ†è§£ä¸ºå¯å¤ç”¨çš„å°æ¨¡å—
3. **é”™è¯¯è™•ç†**ï¼šå®Œå–„çš„é”™è¯¯è™•ç†å’Œé‡è¯•æ©Ÿåˆ¶
4. **æ—¥å¿—è¨˜éŒ„**ï¼šè©³ç´°çš„æ—¥å¿—ä¾¿äºé™¤éŒ¯å’Œç¶­è­·
5. **æ¸¬è©¦é©—è­‰**ï¼šå……åˆ†æ¸¬è©¦å„ç§è¾¹ç•Œæƒ…å†µ

---

*å‰µå»ºæ™‚é–“: 2026-01-31*
# æ›´æ–°
*åˆ†é¡: 3 Resources*
