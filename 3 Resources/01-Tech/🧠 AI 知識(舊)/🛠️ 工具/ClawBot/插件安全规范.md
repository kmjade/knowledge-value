---
title: å¤–æ›å®‰å…¨è¦ç¯„
status: active
priority: high
tags: [clawdbot, security, plugins, best-practices]
aliases: [å¤–æ›å®‰å…¨, Security Guide]
created: 2026-01-31
modified: 2026-01-31
---

# å¤–æ›å®‰å…¨è¦ç¯„

> æœ¬æ–‡æª”å®šä¹‰äº† ClawdBot å¤–æ›é–‹ç™¼çš„å®‰å…¨æ¨™æº–ï¼Œå¸®åŠ©é–‹ç™¼è€…æ§‹å»ºå®‰å…¨å¯é çš„å¤–æ›ã€‚

## ğŸ“‹ ç›®éŒ„

- [å®‰å…¨åŸå‰‡](#å®‰å…¨åŸå‰‡)
# ç®¡ç†
- [ä»£ç¢¼å®‰å…¨](#ä»£ç¢¼å®‰å…¨)
- [æ•¸æ“šå®‰å…¨](#æ•¸æ“šå®‰å…¨)
- [é€šè¨Šå®‰å…¨](#é€šè¨Šå®‰å…¨)
- [ä¾èµ–å®‰å…¨](#ä¾èµ–å®‰å…¨)
- [å®¡è®¡ä¸ç›£æ§](#å®¡è®¡ä¸ç›£æ§)
- [å®‰å…¨æ¸¬è©¦](#å®‰å…¨æ¸¬è©¦)
- [åº”æ€¥éŸ¿æ‡‰](#åº”æ€¥éŸ¿æ‡‰)

---

## å®‰å…¨åŸå‰‡

### æ ¸å¿ƒå®‰å…¨åŸå‰‡

1. **æœ€å°æƒé™åŸå‰‡**
   - å¤–æ›åªåº”è¯·æ±‚å®Œæˆä»»å‹™æ‰€éœ€çš„æœ€å°æƒé™
   - é™åˆ¶å¯¹ç³»çµ±è³‡æºã€ç¶²è·¯ã€æª”æ¡ˆçš„è®¿é—®

2. **çºµæ·±é˜²å¾¡**
   - å¤šå±‚å®‰å…¨é˜²æŠ¤ï¼šè¼¸å…¥é©—è­‰ â†’ æƒé™æª¢æŸ¥ â†’ æ²™ç®±éš”ç¦» â†’ å®¡è®¡æ—¥å¿—

3. **é›¶ä¿¡ä»»**
   - ä¸ä¿¡ä»»ä»»ä½•å¤–éƒ¨è¼¸å…¥
   - é©—è­‰æ‰€æœ‰æ¥è‡ªä½¿ç”¨è€…ã€APIã€å¤–æ›çš„æ•¸æ“š

4. **å®‰å…¨é»˜è®¤**
# é…ç½®
   - æ•æ„Ÿæ“ä½œéœ€è¦æ˜¾å¼æˆæƒ

### å®‰å…¨æˆç†Ÿåº¦æ¨¡å‹

```
çº§åˆ« 1: åŸºç¤å®‰å…¨
â”œâ”€ è¼¸å…¥é©—è­‰
â”œâ”€ é”™è¯¯è™•ç†
â””â”€ åŸºæœ¬æ—¥å¿—

çº§åˆ« 2: æ¨™æº–å®‰å…¨
â”œâ”€ æƒé™æ§åˆ¶
â”œâ”€ æ•¸æ“šåŠ å¯†
â”œâ”€ ä¾èµ–æ‰«æ
â””â”€ å®‰å…¨å®¡è®¡

çº§åˆ« 3: é«˜çº§å®‰å…¨
â”œâ”€ æ²™ç®±éš”ç¦»
â”œâ”€ æŒçºŒç›£æ§
â”œâ”€ å®‰å…¨æ¸¬è©¦è‡ªå‹•åŒ–
â””â”€ åº”æ€¥éŸ¿æ‡‰æµç¨‹

çº§åˆ« 4: ä¼ä¸šçº§å®‰å…¨
â”œâ”€ å®šæœŸå®‰å…¨å®¡è®¡
â”œâ”€ æ¸—é€æ¸¬è©¦
â”œâ”€ åˆè§„æ€§æª¢æŸ¥
â””â”€ å®‰å…¨åŸ¹è®­
```

---

# ç®¡ç†

### æƒé™å£°æ˜

åœ¨ `manifest.yaml` ä¸­æ˜ç¡®å£°æ˜æ‰€éœ€æƒé™ï¼š

```yaml
# manifest.yaml
permissions:
  # ç¶²è·¯è®¿é—®æƒé™
  network:
    allowed_hosts:
      - "api.example.com:443"
      - "cdn.example.com:443"
    blocked_hosts:
      - "localhost"
      - "internal.company.local"
    blocked_ports: [22, 23, 8080]

  # æª”æ¡ˆç³»çµ±è®¿é—®
  filesystem:
    read:
      - "./config/*"
      - "./templates/*"
    write:
      - "./logs/*"
      - "./cache/*"
    denied:
      - "/etc/*"
      - "/root/*"
      - "/home/*"

  # ç’°å¢ƒå˜é‡è®¿é—®
  environment:
    - "API_KEY"
    - "DATABASE_URL"
    - "SECRET_KEY"

  # è³‡æ–™åº«è®¿é—®
  database:
    tables:
      read: ["users", "logs"]
      write: ["logs"]
    denied_tables: ["admin_users", "system_config"]

  # ç³»çµ±å‘½ä»¤æ‰§è¡Œ
  system:
    allowed_commands:
      - "date"
      - "echo"
    denied_commands: ["rm", "sudo", "bash"]
```

### æƒé™é©—è­‰

```python
from clawdbot.security import PermissionChecker, SecurityError

class SecurePlugin(BasePlugin):
    def __init__(self, config):
        super().__init__(config)
        self.permission_checker = PermissionChecker()

    async def execute(self, inputs, context):
        # é©—è­‰æ‰§è¡Œæƒé™
        if not await self.permission_checker.check_permission(
            plugin_id=self.metadata["name"],
            action="execute",
            context=context
        ):
            raise SecurityError("æƒé™ä¸è¶³ï¼Œç„¡æ³•æ‰§è¡Œæ­¤æ“ä½œ")

        # é©—è­‰æ•¸æ“šè®¿é—®æƒé™
        if "user_id" in inputs:
            if not await self.permission_checker.can_access_user_data(
                context.user_id,
                inputs["user_id"]
            ):
                raise SecurityError("ç„¡æƒè®¿é—®å…¶ä»–ä½¿ç”¨è€…çš„æ•¸æ“š")

        # æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        result = await self.process_data(inputs)
        return result
```

### æƒé™å®¡è®¡

```python
class PermissionAuditor:
    """æƒé™å®¡è®¡å™¨"""

    async def audit_plugin_permissions(self, plugin_id: str):
        """å®¡è®¡å¤–æ›æƒé™ä½¿ç”¨æƒ…å†µ"""

        # è·å–å¤–æ›å£°æ˜çš„æƒé™
        declared_perms = await self.get_declared_permissions(plugin_id)

        # è·å–å®é™…ä½¿ç”¨çš„æƒé™
        used_perms = await self.get_used_permissions(plugin_id)

        # æª¢æŸ¥æœªå£°æ˜çš„æƒé™ä½¿ç”¨
        undeclared = used_perms - declared_perms

        # æª¢æŸ¥æœªä½¿ç”¨çš„æƒé™å£°æ˜
        unused = declared_perms - used_perms

        report = {
            "plugin_id": plugin_id,
            "declared_permissions": list(declared_perms),
            "used_permissions": list(used_perms),
            "undeclared_usage": list(undeclared),
            "unused_declarations": list(unused),
            "compliance_score": self.calculate_compliance_score(declared_perms, used_perms)
        }

        return report
```

---

## ä»£ç¢¼å®‰å…¨

### è¼¸å…¥é©—è­‰

```python
import re
from pydantic import BaseModel, validator, Field
from typing import List

class UserInputModel(BaseModel):
    """ä½¿ç”¨è€…è¼¸å…¥æ¨¡å‹"""

    email: str = Field(..., description="ä½¿ç”¨è€…é‚®ç®±")
    username: str = Field(..., min_length=3, max_length=50)
    message: str = Field(..., max_length=1000)
    age: int = Field(..., ge=0, le=150)

    @validator('email')
    def validate_email(cls, v):
        """é©—è­‰é‚®ç®±æ ¼å¼"""
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', v):
            raise ValueError('ç„¡æ•ˆçš„é‚®ç®±æ ¼å¼')
        return v.lower()  # è¦ç¯„åŒ–é‚®ç®±

    @validator('username')
    def validate_username(cls, v):
        """é©—è­‰ä½¿ç”¨è€…å"""
        if not re.match(r'^[a-zA-Z0-9_-]+$', v):
            raise ValueError('ä½¿ç”¨è€…ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦')
        return v

    @validator('message')
    def sanitize_message(cls, v):
        """æ¸…ç†è¨Šæ¯å…§å®¹"""
        # ç§»é™¤å±é™©å­—ç¬¦
        dangerous_patterns = [
            r'<script.*?>.*?</script>',  # XSS
            r'javascript:',              # JSä¼ªåè®®
            r'on\w+\s*=',               # äº‹ä»¶è™•ç†å™¨
        ]

        for pattern in dangerous_patterns:
            v = re.sub(pattern, '', v, flags=re.IGNORECASE)

        return v

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # é©—è­‰è¼¸å…¥
        try:
            validated = UserInputModel(**inputs)
        except ValueError as e:
            raise ValidationError(f"è¼¸å…¥é©—è­‰å¤±è´¥: {e}")

        # ä½¿ç”¨é©—è­‰åçš„æ•¸æ“š
        result = await self.process(validated)
        return result
```

### é˜²æ­¢æ³¨å…¥æ”»å‡»

#### SQL æ³¨å…¥é˜²æŠ¤

```python
# âŒ å±é™©ï¼šSQL æ³¨å…¥é£é™©
async def unsafe_query(user_id: str):
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    return await db.execute(query)

# âœ… å®‰å…¨ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è©¢
async def safe_query(user_id: str):
    query = "SELECT * FROM users WHERE id = %s"
    return await db.execute(query, [user_id])

# âœ… æ›´å®‰å…¨ï¼šä½¿ç”¨ ORM
async def safe_query_with_orm(user_id: str):
    return await User.objects.filter(id=user_id).all()
```

#### å‘½ä»¤æ³¨å…¥é˜²æŠ¤

```python
import subprocess
import shlex

class CommandExecutor:
    def __init__(self, allowed_commands: List[str]):
        self.allowed_commands = set(allowed_commands)

    async def safe_execute(self, command: str, args: List[str]):
        """å®‰å…¨æ‰§è¡Œå‘½ä»¤"""
        # 1. é©—è­‰å‘½ä»¤æ˜¯å¦åœ¨ç™½åå•ä¸­
        if command not in self.allowed_commands:
            raise SecurityError(f"ä¸å…è®¸æ‰§è¡Œçš„å‘½ä»¤: {command}")

        # 2. è½¬ä¹‰å‚æ•°
        safe_args = [shlex.quote(arg) for arg in args]

        # 3. æ§‹å»ºå®‰å…¨å‘½ä»¤
        safe_command = f"{command} {' '.join(safe_args)}"

        # 4. æ‰§è¡Œï¼ˆä½¿ç”¨ subprocess è€Œé os.systemï¼‰
        result = subprocess.run(
            safe_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )

        return result.stdout
```

#### XSS é˜²æŠ¤

```python
import html
from markupsafe import escape

class XSSProtection:
    @staticmethod
    def sanitize_user_input(text: str) -> str:
        """æ¸…ç†ä½¿ç”¨è€…è¼¸å…¥ï¼Œé˜²æ­¢ XSS"""
        # è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦
        escaped = html.escape(text)

        # ç§»é™¤å±é™©æ¨™ç±¤
        dangerous_tags = ['<script', '<iframe', '<object', '<embed']
        for tag in dangerous_tags:
            escaped = escaped.replace(tag, f"&lt;{tag[1:]}")

        return escaped

    @staticmethod
    def safe_render(template: str, context: dict) -> str:
        """å®‰å…¨æ¸²æŸ“æ¨¡æ¿"""
        # ä½¿ç”¨ Jinja2 çš„è‡ªå‹•è½¬ä¹‰
        from jinja2 import Template

        template = Template(template, autoescape=True)
        return template.render(**context)
```

# ç®¡ç†

```python
import os
import base64
from cryptography.fernet import Fernet
from typing import Optional

class SecureCredentials:
# ç®¡ç†

    def __init__(self):
        # ä»ç’°å¢ƒå˜é‡è®€å–åŠ å¯†å¯†é’¥
        encryption_key = os.getenv("ENCRYPTION_KEY")
        if not encryption_key:
            raise ValueError("æœªè¨­ç½® ENCRYPTION_KEY ç’°å¢ƒå˜é‡")

        self.cipher = Fernet(encryption_key.encode())

    def encrypt(self, plaintext: str) -> str:
        """åŠ å¯†æ•¸æ“š"""
        encrypted = self.cipher.encrypt(plaintext.encode())
        return base64.b64encode(encrypted).decode()

    def decrypt(self, ciphertext: str) -> str:
        """è§£å¯†æ•¸æ“š"""
        encrypted = base64.b64decode(ciphertext.encode())
        decrypted = self.cipher.decrypt(encrypted)
        return decrypted.decode()

    def get_api_key(self, service: str) -> str:
        """è·å– API å¯†é’¥"""
        # ä¼˜å…ˆä»ç’°å¢ƒå˜é‡è®€å–
        env_key = f"{service.upper()}_API_KEY"
        key = os.getenv(env_key)

        if key:
            return key

        # ä»åŠ å¯†å„²å­˜è®€å–
        from clawdbot.storage import SecretStorage
        storage = SecretStorage()
        encrypted_key = storage.get(f"{service}.key")

        if encrypted_key:
            return self.decrypt(encrypted_key)

        raise ValueError(f"æœªæ‰¾åˆ° {service} çš„ API å¯†é’¥")

# ä½¿ç”¨ç¤ºä¾‹
credentials = SecureCredentials()

class SecurePlugin(BasePlugin):
    def __init__(self, config):
        super().__init__(config)
        self.credentials = SecureCredentials()
        self.api_key = self.credentials.get_api_key("example_service")
```

---

## æ•¸æ“šå®‰å…¨

### æ•¸æ“šåŠ å¯†

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import os

class DataEncryption:
    """æ•¸æ“šåŠ å¯†å·¥å…·"""

    def __init__(self, password: str):
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        salt = b'salt_'  # å®é™…æ‡‰ç”¨ç¨‹å¼ä¸­æ‡‰è©²ä½¿ç”¨éšæœºç›
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        self.key = kdf.derive(password.encode())
        self.cipher = Fernet(Fernet.generate_key())  # ä½¿ç”¨ç”Ÿæˆçš„å¯†é’¥

    def encrypt_sensitive_field(self, field_name: str, value: str) -> str:
        """åŠ å¯†æ•æ„Ÿå­—æ®µ"""
        # åªåŠ å¯†æŒ‡å®šçš„æ•æ„Ÿå­—æ®µ
        sensitive_fields = ['password', 'token', 'secret', 'credit_card']

        if field_name.lower() in sensitive_fields:
            return self.cipher.encrypt(value.encode()).decode()

        return value

    def decrypt_sensitive_field(self, field_name: str, encrypted_value: str) -> str:
        """è§£å¯†æ•æ„Ÿå­—æ®µ"""
        sensitive_fields = ['password', 'token', 'secret', 'credit_card']

        if field_name.lower() in sensitive_fields:
            decrypted = self.cipher.decrypt(encrypted_value.encode())
            return decrypted.decode()

        return encrypted_value
```

### æ•æ„Ÿæ•¸æ“šè™•ç†

```python
class SensitiveDataHandler:
    """æ•æ„Ÿæ•¸æ“šè™•ç†å™¨"""

    @staticmethod
    def mask_data(data: dict, sensitive_fields: List[str]) -> dict:
        """é®è”½æ•æ„Ÿæ•¸æ“š"""
        masked = data.copy()

        for field in sensitive_fields:
            if field in masked:
                value = str(masked[field])
# é¡¯ç¤º
                if len(value) > 4:
                    masked[field] = value[:2] + '*' * (len(value) - 4) + value[-2:]
                else:
                    masked[field] = '***'

        return masked

    @staticmethod
    def should_log_data(data: dict) -> dict:
        """å‡†å¤‡ç”¨äºæ—¥å¿—çš„æ•¸æ“š"""
        # ç§»é™¤æˆ–é®è”½æ•æ„Ÿå­—æ®µ
        sensitive_fields = [
            'password', 'token', 'secret',
            'credit_card', 'ssn', 'api_key'
        ]

        return SensitiveDataHandler.mask_data(data, sensitive_fields)

# ä½¿ç”¨ç¤ºä¾‹
handler = SensitiveDataHandler()

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # è™•ç†æ•æ„Ÿæ•¸æ“š
        self.logger.info(
            "è™•ç†è¯·æ±‚",
            extra=handler.should_log_data(inputs)
        )

        # ä¸è¦è¨˜éŒ„å®Œæ•´æ•¸æ“š
        self.logger.info(f"è¯·æ±‚ID: {context.task_id}")  # å®‰å…¨
        self.logger.info(f"è¯·æ±‚æ•¸æ“š: {inputs}")  # ä¸å®‰å…¨ï¼

        result = await self.process(inputs)
        return result
```

---

## é€šè¨Šå®‰å…¨

# é…ç½®

```python
import ssl
import aiohttp

class SecureHTTPClient:
    """å®‰å…¨çš„ HTTP å®¢æˆ·ç«¯"""

    def __init__(self):
        self.ssl_context = ssl.create_default_context()
        self.ssl_context.verify_mode = ssl.CERT_REQUIRED
        self.ssl_context.check_hostname = True

    async def get(self, url: str, headers: dict = None):
        """å®‰å…¨ GET è¯·æ±‚"""
        async with aiohttp.ClientSession() as session:
            async with session.get(
                url,
                ssl=self.ssl_context,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                if response.status != 200:
                    raise HTTPError(f"è¯·æ±‚å¤±è´¥: {response.status}")

                return await response.json()

    async def post(self, url: str, data: dict, headers: dict = None):
        """å®‰å…¨ POST è¯·æ±‚"""
        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                json=data,
                ssl=self.ssl_context,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                if response.status != 200:
                    raise HTTPError(f"è¯·æ±‚å¤±è´¥: {response.status}")

                return await response.json()

# ä½¿ç”¨ç¤ºä¾‹
client = SecureHTTPClient()

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # ä½¿ç”¨å®‰å…¨å®¢æˆ·ç«¯
        result = await client.post(
            "https://api.example.com/data",
            data=inputs,
            headers={"Authorization": f"Bearer {self.api_key}"}
        )

        return PluginResult(success=True, data=result)
```

### API å®‰å…¨

```python
import hashlib
import hmac
import time
from typing import Dict

class APISecurity:
    """API å®‰å…¨å·¥å…·"""

    @staticmethod
    def generate_signature(
        method: str,
        url: str,
        params: Dict,
        secret_key: str
    ) -> str:
        """ç”Ÿæˆ API ç­¾å"""
# æ’åº
        sorted_params = sorted(params.items())

        # 2. æ§‹å»ºç­¾åå­—ç¬¦ä¸²
        sign_string = f"{method.upper()}&{url}&" + "&".join(
            f"{k}={v}" for k, v in sorted_params
        )

        # 3. ä½¿ç”¨ HMAC-SHA256 ç”Ÿæˆç­¾å
        signature = hmac.new(
            secret_key.encode(),
            sign_string.encode(),
            hashlib.sha256
        ).hexdigest()

        return signature

    @staticmethod
    def validate_signature(
        received_signature: str,
        method: str,
        url: str,
        params: Dict,
        secret_key: str
    ) -> bool:
        """é©—è­‰ API ç­¾å"""
        expected_signature = APISecurity.generate_signature(
            method, url, params, secret_key
        )
        return hmac.compare_digest(received_signature, expected_signature)

# ä½¿ç”¨ç¤ºä¾‹
security = APISecurity()

class SecureAPIPlugin(BasePlugin):
    async def call_external_api(self, endpoint: str, data: dict):
        """èª¿ç”¨å¤–éƒ¨ APIï¼ˆå¸¦ç­¾åï¼‰"""
        params = {
            **data,
            "timestamp": int(time.time()),
            "nonce": self.generate_nonce()
        }

        signature = security.generate_signature(
            "POST",
            endpoint,
            params,
            self.api_secret
        )

        result = await self.http_client.post(
            endpoint,
            data={**params, "signature": signature}
        )

        return result
```

---

## ä¾èµ–å®‰å…¨

### ä¾èµ–æ¼æ´æ‰«æ

```bash
# å®‰è£å®‰å…¨æ‰«æå·¥å…·
pip install safety bandit

# æ‰«æå·²çŸ¥æ¼æ´
safety check

# åˆ†æ
bandit -r my_plugin/

# æª¢æŸ¥è¿‡æœŸä¾èµ–
pip list --outdated
```

### ä¾èµ–ç™½åå•

```python
# requirements-safety.txt
# åªåŒ…å«ç¶“éå®‰å…¨å®¡è®¡çš„ä¾èµ–

# æ ¸å¿ƒä¾èµ–
cryptography>=41.0.0
pydantic>=2.0.0
aiohttp>=3.8.0

# å®‰å…¨å·¥å…·
bandit>=1.7.0
safety>=2.3.0
```

# æ›´æ–°

```python
import subprocess
import re
from typing import List, Dict

class DependencyManager:
# ç®¡ç†

    async def check_for_vulnerabilities(self) -> Dict[str, List[str]]:
        """æª¢æŸ¥ä¾èµ–æ¼æ´"""
        vulnerabilities = {}

        # é‹è¡Œ safety check
        result = subprocess.run(
            ["safety", "check", "--json"],
            capture_output=True,
            text=True
        )

        if result.stdout:
            import json
            report = json.loads(result.stdout)
            vulnerabilities = {
                vuln["package"]: vuln.get("affected_versions", [])
                for vuln in report
            }

        return vulnerabilities

    async def auto_update_secure(self, package: str):
# æ›´æ–°
# ç‰ˆæœ¬
        versions = await self.get_available_versions(package)

# ç‰ˆæœ¬
        safe_version = self.select_safe_version(package, versions)

        if safe_version:
# æ›´æ–°
            subprocess.run(
                ["pip", "install", "--upgrade", f"{package}=={safe_version}"],
                check=True
            )
            return True

        return False
```

---

## å®¡è®¡ä¸ç›£æ§

### æ“ä½œæ—¥å¿—

```python
import json
from datetime import datetime
from typing import Dict, Any

class SecurityAuditLogger:
    """å®‰å…¨å®¡è®¡æ—¥å¿—å™¨"""

    def __init__(self, log_file: str):
        self.log_file = log_file

    def log_security_event(
        self,
        event_type: str,
        plugin_id: str,
        user_id: str,
        details: Dict[str, Any]
    ):
        """è¨˜éŒ„å®‰å…¨äº‹ä»¶"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": event_type,
            "plugin_id": plugin_id,
            "user_id": user_id,
            "ip_address": self.get_client_ip(),
            "user_agent": self.get_user_agent(),
            "details": self.sanitize_details(details)
        }

        # å¯«å…¥æ—¥å¿—æª”æ¡ˆ
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + "\n")

    def log_permission_violation(
        self,
        plugin_id: str,
        attempted_action: str,
        required_permission: str
    ):
        """è¨˜éŒ„æƒé™è¿è§„"""
        self.log_security_event(
            event_type="PERMISSION_VIOLATION",
            plugin_id=plugin_id,
            user_id=self.get_current_user(),
            details={
                "attempted_action": attempted_action,
                "required_permission": required_permission,
                "severity": "high"
            }
        )

    def sanitize_details(self, details: Dict[str, Any]) -> Dict[str, Any]:
        """æ¸…ç†æ•æ„Ÿè³‡è¨Š"""
        sensitive_keys = ['password', 'token', 'secret', 'api_key']

        sanitized = details.copy()
        for key in sensitive_keys:
            if key in sanitized:
                sanitized[key] = "***REDACTED***"

        return sanitized
```

### å®æ—¶ç›£æ§

```python
from collections import deque
from datetime import datetime, timedelta
import asyncio

class SecurityMonitor:
    """å®‰å…¨ç›£æ§å™¨"""

    def __init__(self):
        # ä¿ç•™æœ€è¿‘1000ä¸ªäº‹ä»¶
        self.events = deque(maxlen=1000)
        self.alerts = []

    async def monitor_plugin_activity(self, plugin_id: str):
        """ç›£æ§å¤–æ›æ´»åŠ¨"""
        recent_events = self.get_recent_events(plugin_id, minutes=5)

        # æª¢æŸ¥å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
        anomalies = self.detect_anomalies(recent_events)

        if anomalies:
            await self.handle_anomalies(plugin_id, anomalies)

    def detect_anomalies(self, events: list) -> list:
        """æ£€æµ‹å¼‚å¸¸è¡Œä¸º"""
        anomalies = []

        # 1. æª¢æŸ¥è¯·æ±‚é¢‘ç‡å¼‚å¸¸
        request_count = len(events)
        if request_count > 100:  # 5åˆ†é’Ÿå†…è¶…è¿‡100æ¬¡è¯·æ±‚
            anomalies.append({
                "type": "high_request_rate",
                "count": request_count,
                "severity": "medium"
            })

        # 2. æª¢æŸ¥å¤±è´¥ç‡å¼‚å¸¸
        failures = [e for e in events if e.get("success") is False]
        failure_rate = len(failures) / len(events) if events else 0

        if failure_rate > 0.5:  # å¤±è´¥ç‡è¶…è¿‡50%
            anomalies.append({
                "type": "high_failure_rate",
                "rate": failure_rate,
                "severity": "high"
            })

        # 3. æª¢æŸ¥å¼‚å¸¸IP
        ips = set(e.get("ip_address") for e in events)
        if len(ips) > 10:  # æ¥è‡ªè¶…è¿‡10ä¸ªä¸åŒIP
            anomalies.append({
                "type": "multiple_ips",
                "count": len(ips),
                "severity": "low"
            })

        return anomalies

    async def handle_anomalies(self, plugin_id: str, anomalies: list):
        """è™•ç†å¼‚å¸¸"""
        for anomaly in anomalies:
            if anomaly["severity"] == "high":
                # ä¸¥é‡å¼‚å¸¸ï¼šæš«åœå¤–æ›
                await self.suspend_plugin(plugin_id)
                await self.notify_admin(plugin_id, anomaly)
            elif anomaly["severity"] == "medium":
                # ä¸­ç­‰å¼‚å¸¸ï¼šè­¦å‘Š
                await self.send_warning(plugin_id, anomaly)
            else:
                # è½»å¾®å¼‚å¸¸ï¼šè¨˜éŒ„
                self.logger.warning(f"æ£€æµ‹åˆ°å¼‚å¸¸: {anomaly}")
```

---

## å®‰å…¨æ¸¬è©¦

### å•å…ƒæ¸¬è©¦

```python
import pytest
from my_plugin.security import InputValidator

class TestSecurity:
    """å®‰å…¨æ¸¬è©¦å¥—ä»¶"""

    def test_sql_injection_protection(self):
        """æ¸¬è©¦SQLæ³¨å…¥é˜²æŠ¤"""
        malicious_inputs = [
            "1' OR '1'='1",
            "1'; DROP TABLE users; --",
            "1' UNION SELECT * FROM admin_users; --"
        ]

        validator = InputValidator()

        for input_str in malicious_inputs:
            # æ‡‰è©²è¢«æ‹’çµ•æˆ–æ¸…ç†
            result = validator.sanitize(input_str)
            assert "DROP TABLE" not in result
            assert "UNION SELECT" not in result

    def test_xss_protection(self):
        """æ¸¬è©¦XSSé˜²æŠ¤"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>"
        ]

        validator = InputValidator()

        for payload in xss_payloads:
            result = validator.sanitize(payload)
            assert "<script" not in result
            assert "javascript:" not in result
            assert "onerror=" not in result

    def test_command_injection_protection(self):
        """æ¸¬è©¦å‘½ä»¤æ³¨å…¥é˜²æŠ¤"""
        malicious_commands = [
            "; cat /etc/passwd",
            "&& rm -rf /",
            "| ls -la",
            "`whoami`"
        ]

        executor = SecureCommandExecutor(["date"])

        for cmd in malicious_commands:
            # æ‡‰è©²è¢«æ‹’çµ•
            with pytest.raises(SecurityError):
                executor.execute(cmd)
```

### æ•´åˆæ¸¬è©¦

```python
@pytest.mark.security
class TestPluginSecurity:
    """å¤–æ›å®‰å…¨æ•´åˆæ¸¬è©¦"""

    async def test_permission_enforcement(self):
        """æ¸¬è©¦æƒé™å¼ºåˆ¶æ‰§è¡Œ"""
        plugin = MyPlugin({"permissions": []})

        # å°è¯•æ‰§è¡Œéœ€è¦æƒé™çš„æ“ä½œ
        result = await plugin.execute(
            inputs={"action": "admin_only"},
            context=MockContext(user_role="user")
        )

        assert result.success is False
        assert "permission" in result.error.lower()

    async def test_data_leak_prevention(self):
        """æ¸¬è©¦æ•¸æ“šæ³„éœ²é˜²æŠ¤"""
        plugin = MyPlugin({})

        # æ‰§è¡Œå¯èƒ½æ³„éœ²æ•¸æ“šçš„æ“ä½œ
        result = await plugin.execute(
            inputs={"sensitive_data": "secret"},
            context=MockContext()
        )

        # æª¢æŸ¥æ—¥å¿—ä¸­ä¸åŒ…å«æ•æ„Ÿæ•¸æ“š
        log_output = self.get_plugin_logs(plugin)
        assert "secret" not in log_output
        assert "***" in log_output  # æ•æ„Ÿæ•¸æ“šè¢«é®è”½
```

### æ¸—é€æ¸¬è©¦

```python
class PenetrationTest:
    """æ¸—é€æ¸¬è©¦å·¥å…·"""

    async def test_sql_injection(self, endpoint: str):
        """SQLæ³¨å…¥æ¸¬è©¦"""
        payloads = [
            "1' OR '1'='1",
            "1' UNION SELECT username, password FROM users--",
            "1'; DROP TABLE users; --"
        ]

        results = []

        for payload in payloads:
            try:
                response = await self.send_request(endpoint, {"id": payload})
                if "error" not in response.lower():
                    results.append({
                        "payload": payload,
                        "vulnerable": True,
                        "response": response
                    })
            except Exception:
                pass

        return results

    async def test_xss(self, endpoint: str):
        """XSSæ¸¬è©¦"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]

        results = []

        for payload in payloads:
            try:
                response = await self.send_request(endpoint, {"input": payload})
                if "<script" in response or "alert" in response:
                    results.append({
                        "payload": payload,
                        "vulnerable": True
                    })
            except Exception:
                pass

        return results
```

---

## åº”æ€¥éŸ¿æ‡‰

### å®‰å…¨äº‹ä»¶åˆ†é¡

```python
from enum import Enum

class SecurityEventType(Enum):
    """å®‰å…¨äº‹ä»¶ç±»å‹"""
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    DATA_LEAK = "data_leak"
    MALICIOUS_CODE = "malicious_code"
    RESOURCE_ABUSE = "resource_abuse"
    PERMISSION_VIOLATION = "permission_violation"
    BRUTE_FORCE = "brute_force"

class SecuritySeverity(Enum):
    """å®‰å…¨äº‹ä»¶ä¸¥é‡æ€§"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
```

### åº”æ€¥éŸ¿æ‡‰æµç¨‹

```python
class SecurityIncidentHandler:
    """å®‰å…¨äº‹ä»¶è™•ç†å™¨"""

    def __init__(self):
        self.handlers = {
            SecuritySeverity.CRITICAL: self.handle_critical,
            SecuritySeverity.HIGH: self.handle_high,
            SecuritySeverity.MEDIUM: self.handle_medium,
            SecuritySeverity.LOW: self.handle_low
        }

    async def handle_incident(
        self,
        event_type: SecurityEventType,
        severity: SecuritySeverity,
        details: dict
    ):
        """è™•ç†å®‰å…¨äº‹ä»¶"""
        # 1. è¨˜éŒ„äº‹ä»¶
        await self.log_incident(event_type, severity, details)

        # 2. è©•ä¼°å½±å“
        impact = await self.assess_impact(event_type, details)

        # 3. æ ¹æ®ä¸¥é‡æ€§æ‰§è¡ŒéŸ¿æ‡‰
        handler = self.handlers.get(severity, self.handle_low)
        await handler(event_type, details, impact)

        # 4. ç”Ÿæˆå ±å‘Š
        report = await self.generate_incident_report(event_type, severity, impact)
        await self.send_report(report)

    async def handle_critical(self, event_type, details, impact):
        """è™•ç†ä¸¥é‡äº‹ä»¶"""
        # 1. ç«‹å³åœæ­¢ç›¸é—œå¤–æ›
        plugin_id = details.get("plugin_id")
        await self.suspend_plugin(plugin_id)

        # 2. é˜»æ­¢ç›¸é—œä½¿ç”¨è€…/IP
        if "user_id" in details:
            await self.block_user(details["user_id"])

        if "ip_address" in details:
            await self.block_ip(details["ip_address"])

        # 3. é€šçŸ¥å®‰å…¨åœ˜éšŠ
        await self.notify_security_team(event_type, details)

        # 4. ä¿ç•™è¯æ®
        await self.preserve_evidence(details)

    async def handle_high(self, event_type, details, impact):
        """è™•ç†é«˜å±äº‹ä»¶"""
        # 1. æš«åœå¤–æ›
        await self.suspend_plugin(details.get("plugin_id"))

# ç®¡ç†
        await self.notify_admin(event_type, details)

        # 3. å¢åŠ ç›£æ§é¢‘ç‡
        await self.increase_monitoring(details.get("plugin_id"))

    async def handle_medium(self, event_type, details, impact):
        """è™•ç†ä¸­ç­‰é£é™©äº‹ä»¶"""
        # 1. ç™¼é€è­¦å‘Š
        await self.send_warning(event_type, details)

        # 2. è¨˜éŒ„æ—¥å¿—
        await self.log_warning(event_type, details)

    async def handle_low(self, event_type, details, impact):
        """è™•ç†ä½é£é™©äº‹ä»¶"""
        # ä»…è¨˜éŒ„æ—¥å¿—
        await self.log_info(event_type, details)
```

### æ¢å¾©æµç¨‹

```python
class IncidentRecovery:
    """äº‹ä»¶æ¢å¾©"""

    async def restore_plugin(self, plugin_id: str, incident_report: dict):
        """æ¢å¾©å¤–æ›"""

        # 1. é©—è­‰å¨èƒå·²æ¶ˆé™¤
        if not await self.verify_threat_eliminated(plugin_id):
            raise RecoveryError("å¨èƒæœªæ¶ˆé™¤ï¼Œç„¡æ³•æ¢å¾©")

        # 2. é©—è­‰å¤–æ›å®Œæ•´æ€§
        if not await self.verify_plugin_integrity(plugin_id):
            await self.reinstall_plugin(plugin_id)

# é…ç½®
        await self.restore_config(plugin_id)

        # 4. å¯ç”¨å¤–æ›ï¼ˆç›£æ§æ¨¡å¼ï¼‰
        await self.enable_plugin(plugin_id, mode="monitored")

        # 5. æŒçºŒç›£æ§
        await self.monitor_recovery(plugin_id)

        # 6. å¦‚æœç¨³å®šï¼Œåˆ‡æ›åˆ°æ­£å¸¸æ¨¡å¼
        await asyncio.sleep(300)  # ç›£æ§5åˆ†é’Ÿ
        if await self.is_stable(plugin_id):
            await self.enable_plugin(plugin_id, mode="normal")
```

---

## å®‰å…¨æª¢æŸ¥æ¸…å–®

### å¤–æ›ç™¼ä½ˆå‰æª¢æŸ¥

```markdown
## å®‰å…¨æª¢æŸ¥æ¸…å–®

### ä»£ç¢¼å®‰å…¨
- [ ] æ‰€æœ‰ä½¿ç”¨è€…è¼¸å…¥éƒ½ç¶“éé©—è­‰å’Œæ¸…ç†
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è©¢é˜²æ­¢ SQL æ³¨å…¥
- [ ] æ²¡æœ‰ç¡¬ç¼–ç çš„å¯†é’¥æˆ–å‡­è¯
- [ ] æ•æ„Ÿæ•¸æ“šå·²åŠ å¯†å„²å­˜
- [ ] å¯¦ç¾äº†é€‚å½“çš„é”™è¯¯è™•ç†ï¼ˆä¸æ³„éœ²ç³»çµ±è³‡è¨Šï¼‰

# ç®¡ç†
- [ ] å¤–æ›ä»…è¯·æ±‚å¿…è¦çš„æƒé™
- [ ] æª”æ¡ˆç³»çµ±è®¿é—®é™åˆ¶åœ¨æŒ‡å®šç›®éŒ„
- [ ] ç¶²è·¯è®¿é—®é™åˆ¶åœ¨å¿…è¦çš„ç¶²ç¶²åŸŸåç¨±ç¨±å’Œç«¯å£
- [ ] ç’°å¢ƒå˜é‡è®¿é—®ç¶“éæˆæƒ

### æ•¸æ“šå®‰å…¨
- [ ] æ•æ„Ÿæ•¸æ“šåœ¨å‚³è¼¸ä¸­ä½¿ç”¨ HTTPS
- [ ] æ•æ„Ÿæ•¸æ“šåœ¨å„²å­˜ä¸­å·²åŠ å¯†
- [ ] æ—¥å¿—ä¸­ä¸åŒ…å«æ•æ„Ÿè³‡è¨Š
- [ ] å¯¦ç¾äº†æ•¸æ“šè„±æ•åŠŸèƒ½

### é€šè¨Šå®‰å…¨
- [ ] æ‰€æœ‰ç¶²è·¯é€šè¨Šä½¿ç”¨ TLS
- [ ] API èª¿ç”¨ä½¿ç”¨ç­¾åé©—è­‰
- [ ] å¯¦ç¾äº†é˜²é‡æ”¾æ”»å‡»æ©Ÿåˆ¶

### ä¾èµ–å®‰å…¨
- [ ] æ‰€æœ‰ä¾èµ–åŒ…ç¶“éå®‰å…¨å®¡è®¡
- [ ] é‹è¡Œäº†æ¼æ´æ‰«æå·¥å…·
# ç‰ˆæœ¬
# æ›´æ–°

### ç›£æ§å’Œæ—¥å¿—
- [ ] è¨˜éŒ„é—œéµæ“ä½œæ—¥å¿—
- [ ] å¯¦ç¾äº†å®‰å…¨äº‹ä»¶æ£€æµ‹
# é…ç½®
- [ ] æ—¥å¿—å®šæœŸå‚™ä»½å’Œå®¡è®¡

### æ¸¬è©¦
- [ ] ç·¨å¯«äº†å®‰å…¨å•å…ƒæ¸¬è©¦
- [ ] é€²è¡Œäº†æ¸—é€æ¸¬è©¦
- [ ] æ¸¬è©¦äº†é”™è¯¯å’Œå¼‚å¸¸æƒ…å†µ
- [ ] é©—è­‰äº†æƒé™å¼ºåˆ¶æ‰§è¡Œ
```

---

## åƒè€ƒèµ„æ–™

### å®‰å…¨æ¨™æº–
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [CWE/SANS Top 25](https://cwe.mitre.org/top25/)
- [Python å®‰å…¨æœ€ä½³å¯¦è¸](https://docs.python.org/3/library/security_warnings.html)

### å·¥å…·
# åˆ†æ
- [Safety - ä¾èµ–æ¼æ´æ‰«æ](https://github.com/pyupio/safety)
# åˆ†æ

### ç›¸é—œæ–‡æª”
# æŒ‡å—
# æŒ‡å—
# æŒ‡å—

---

*å‰µå»ºæ™‚é–“: 2026-01-31*
# æ›´æ–°
*åˆ†é¡: 3 Resources*
