---
title: 自定义传输方式
status: active
priority: medium
tags: [esp32/examples, microros/transport]
aliases: [自定义传输方式, 串口传输microROS]
created: 2026-02-19
modified: 2026-02-19
source: https://www.yahboom.com/public/upload/upload-html/1706347462/自定义传输方式.html
related:
  - [[MicroROS机器人控制板]]
  - [[发布话题]]
  - [[串口通讯]]
---

# 自定义传输方式

> 学习ESP32-microROS组件，使用自定义传输方式（串口传输）连接代理。

---

## 目录

- [实验目的](#一实验目的)
- [硬件连接](#二硬件连接)
- [核心代码解析](#三核心代码解析)
- [编译下载烧录固件](#四编译下载烧录固件)
- [实验效果](#五实验效果)

---

## 一、实验目的

学习ESP32-microROS组件，使用自定义传输方式（串口传输）连接代理。

---

## 二、硬件连接

如下图所示，microROS控制板集成了ESP32-S3-WROOM核心模组，自带无线WiFi功能，ESP32-S3核心模组需要连接天线，还需要把type-C数据线连接电脑与microROS控制板作为烧录固件和串口通讯的功能。

![image-20240112174901940](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240112174901940.png)

---

## 三、核心代码解析

程序源码对应的虚拟机路径为：

```
~/esp/Samples/microros_samples/custom_transport
```

由于自定义传输方式需要重新编译生成libmicroros.a静态库，所以本项目不导入extra_components作为外部组件库，需要重新安装micro_ros_espidf_component组件到custom_components目录下，然后导入custom_components作为外部组件库。

出厂虚拟机系统已经安装好custom_components的组件。

编译生成custom版本libmicroros.a静态库的操作与编译extra_components目录下的libmicroros.a静态库的操作流程类似，只是需要修改colcon.meta文件里的"rmw_microxrcedds"参数，并且注意替换编译路径就行。

```c
        "rmw_microxrcedds": {
            "cmake-args": [
                "-DRMW_UXRCE_XML_BUFFER_LENGTH=400",
                "-DRMW_UXRCE_TRANSPORT=custom",
                "-DRMW_UXRCE_MAX_NODES=1",
                "-DRMW_UXRCE_MAX_PUBLISHERS=3",
                "-DRMW_UXRCE_MAX_SUBSCRIPTIONS=3",
                "-DRMW_UXRCE_MAX_SERVICES=1",
                "-DRMW_UXRCE_MAX_CLIENTS=1",
                "-DRMW_UXRCE_MAX_HISTORY=3"
            ]
        },
```

从IDF配置工具里获取相关配置参数。默认使用串口2，波特率为921600，TX引脚为GPIO43，RX引脚为GPIO44，namespace为空，domain ID为20。

```c
#define ROS_NAMESPACE     CONFIG_MICRO_ROS_NAMESPACE
#define ROS_DOMAIN_ID    CONFIG_MICRO_ROS_DOMAIN_ID
#define ROS_UART_NUM     CONFIG_MICRO_ROS_UART_NUM
#define ROS_UART_BAUD    CONFIG_MICRO_ROS_UART_BAUD
#define UART_TXD         CONFIG_MICRO_ROS_UART_TXD
#define UART_RXD         CONFIG_MICRO_ROS_UART_RXD
#define UART_RTS         CONFIG_MICRO_ROS_UART_RTS
#define UART_CTS         CONFIG_MICRO_ROS_UART_CTS
```

初始化microROS的配置，其中ROS_DOMAIN_ID，ROS_AGENT_IP和ROS_AGENT_PORT根据实际需求在IDF配置工具中修改。

```c
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    // 创建rcl初始化选项
    // Create init_options.
    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();

    RCCHECK(rcl_init_options_init(&init_options, allocator));

    // 修改ROS域ID
    // change ros domain id
    RCCHECK(rcl_init_options_set_domain_id(&init_options, ROS_DOMAIN_ID));

    // 初始化rmw选项
    // Initialize the rmw options
    rmw_init_options_t *rmw_options = rcl_init_options_get_rmw_init_options(&init_options);
```

设置microROS自定义传输方式为串口传输方式。

```c
RCCHECK(set_microros_serial_transports_with_options(rmw_options));
```

`set_microros_serial_transports_with_options`函数只要功能是指定传输方式。

```c
rmw_ret_t set_microros_serial_transports_with_options(rmw_init_options_t * rmw_options)
{
   rmw_ret_t ret = RMW_RET_OK;
   static size_t uart_port = ROS_UART_NUM;

   uart_driver_delete(UART_NUM_0);

   ret = rmw_uros_options_set_custom_transport(
        true,
        (void *) &uart_port,
        transport_serial_open,
        transport_serial_close,
        transport_serial_write,
        transport_serial_read,
        rmw_options
   );
   return ret;
}
```

打开串口：

```c
static bool transport_serial_open(struct uxrCustomTransport *transport)
{
   size_t *uart_port = (size_t *)transport->args;
   uart_config_t uart_config = {
       .baud_rate = serial_baudrate,
       .data_bits = UART_DATA_8_BITS,
       .parity = UART_PARITY_DISABLE,
       .stop_bits = UART_STOP_BITS_1,
       .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
   };

   if (uart_param_config(*uart_port, &uart_config) == ESP_FAIL)
   {
       return false;
   }

   if (uart_set_pin(*uart_port, UART_TXD, UART_RXD, UART_RTS, UART_CTS) == ESP_FAIL)
   {
       return false;
   }

   if (uart_driver_install(*uart_port, UART_BUFFER_SIZE * 2, 0, 0, NULL, 0) == ESP_FAIL)
   {
       return false;
   }
   return true;
}
```

关闭串口：

```c
static bool transport_serial_close(struct uxrCustomTransport *transport)
{
   size_t *uart_port = (size_t *)transport->args;
   return uart_driver_delete(*uart_port) == ESP_OK;
}
```

串口写入数据：

```c
static size_t transport_serial_write(struct uxrCustomTransport *transport, const uint8_t *buf, size_t len, uint8_t *err)
{
   size_t *uart_port = (size_t *)transport->args;
   const int txBytes = uart_write_bytes(*uart_port, (const char *)buf, len);
   return txBytes;
}
```

从串口读取数据：

```c
static size_t transport_serial_read(struct uxrCustomTransport *transport, uint8_t *buf, size_t len, int timeout, uint8_t *err)
{
   size_t *uart_port = (size_t *)transport->args;
   const int rxBytes = uart_read_bytes(*uart_port, buf, len, timeout / portTICK_PERIOD_MS);
   return rxBytes;
}
```

尝试连接代理，连接成功才进入下一步，如果连接代理不成功则一直处于连接状态。

```c
   while (1)
   {
       state_agent = rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator);
       if (state_agent == ESP_OK)
       {
           break;
       }
       vTaskDelay(pdMS_TO_TICKS(500));
   }
```

创建节点"custom_transport"，其中ROS_NAMESPACE默认为空，可根据实际在IDF配置工具中修改。

```c
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "custom_transport", ROS_NAMESPACE, &support));
```

创建发布者"custom_publisher"，指定ROS话题信息为std_msgs/msg/Int32类型。

```c
   RCCHECK(rclc_publisher_init_default(
        &publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),
        "custom_publisher"));
```

---

## 四、编译下载烧录固件

使用Type-C数据线连接虚拟机/电脑与microROS控制板，如果系统弹窗选择连接到虚拟机上。

激活ESP-IDF开发环境，注意每次打开新终端都需要先激活ESP-IDF开发环境才可以编译固件。

```bash
source ~/esp/esp-idf/export.sh
```

进入项目目录：

```bash
cd ~/esp/Samples/microros_samples/custom_transport
```

打开ESP-IDF的配置工具。

```bash
idf.py menuconfig
```

打开micro-ROS example-app settings，无特殊需求保持默认配置即可。

![image-20240118163657010](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118163657010.png)

如果有修改，请按S保存，再按Q退出配置工具。

编译、烧录、打开串口模拟器。

```bash
idf.py build flash monitor
```

如果需要退出串口模拟器，请按**Ctrl+]**。

---

## 五、实验效果

开机后，串口模拟器会打印一串乱码，原因是因为microros使用串口发送连接请求并非全是字符，并且默认波特率不适配，所以看起来是乱码。

![image-20240118163933247](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118163933247.png)

此时按Ctrl+]退出模拟器，然后输入以下内容打开串口代理。

```bash
docker run -it --rm -v /dev:/dev -v /dev/shm:/dev/shm --privileged --net=host microros/micro-ros-agent:humble serial --dev /dev/ttyUSB0 -b 921600 -v4
```

![image-20240118164843379](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118164843379.png)

如果连接成功，会打印出相关节点和话题的信息。

![image-20240118164930334](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118164930334.png)

此时再开一个终端，查看当前的节点信号。

```bash
ros2 node list
ros2 node info /custom_transport
```

![image-20240118165148930](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118165148930.png)

订阅/custom_transport话题的数据内容：

```bash
ros2 topic echo /custom_publisher
```

按Ctrl+C退出话题内容。

![image-20240118165508504](https://www.yahboom.com/public/upload/upload-html/1706347462/image-20240118165508504.png)

**注意：由于microros串口代理会占用串口，导致无法烧录，所以在下一次烧录程序之前，需要先把串口代理按Ctrl+C关闭后，再烧录程序。**

---

## 相关文档

- [[发布话题]] - WiFi传输方式
- [[串口通讯]] - ESP32串口基础
- [[安装和启动microROS代理]] - 代理配置说明
