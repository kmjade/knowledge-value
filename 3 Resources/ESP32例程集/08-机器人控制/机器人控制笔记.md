---
title: æœºå™¨äººæ§åˆ¶ç¬”è®°
status: active
priority: medium
tags: [knowledge/robotics, control-theory, kinematics]
aliases: [æœºå™¨äººæ§åˆ¶, Robot Control]
created: 2026-02-19
---

# æœºå™¨äººæ§åˆ¶ç¬”è®°

> æœºå™¨äººæ§åˆ¶æ¶‰åŠè¿åŠ¨å­¦ã€åŠ¨åŠ›å­¦ã€ä¼ æ„Ÿå™¨èåˆã€è·¯å¾„è§„åˆ’ç­‰å¤šä¸ªé¢†åŸŸï¼Œæ˜¯å®ç°æœºå™¨äººè‡ªä¸»è¿åŠ¨çš„æ ¸å¿ƒæŠ€æœ¯ã€‚

---

## ğŸ“‹ æ¦‚è¿°

### æœºå™¨äººæ§åˆ¶ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä¸Šå±‚æ§åˆ¶ç³»ç»Ÿ (ROS2)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ è·¯å¾„è§„åˆ’ â”‚  â”‚ åŠ¨ä½œæœåŠ¡å™¨ â”‚  â”‚ çŠ¶æ€ä¼°è®¡ â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â”‚
â”‚       â”‚            â”‚            â”‚               â”‚
â”‚       â–¼            â–¼            â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚          é€Ÿåº¦æ§åˆ¶å™¨ (PID)           â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ä¸‹å±‚æ§åˆ¶ç³»ç»Ÿ (MicroROS/ESP32)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ ç”µæœºé©±åŠ¨ â”‚  â”‚ ç¼–ç å™¨  â”‚  â”‚ ä¼ æ„Ÿå™¨  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤– å·®é€Ÿè¿åŠ¨å­¦

### è¿åŠ¨å­¦æ¨¡å‹

```
        â†‘ v_linear (çº¿é€Ÿåº¦)
        â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”
    â”‚       â”‚
    â”‚   â—   â”‚ â†’ Ï‰_angular (è§’é€Ÿåº¦)
    â”‚       â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”˜
        â”‚
        â–¼
```

### å‰å‘è¿åŠ¨å­¦

ç»™å®šå·¦å³è½®é€Ÿåº¦ï¼Œè®¡ç®—æœºå™¨äººçº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ï¼š

```python
def forward_kinematics(v_left, v_right, wheelbase):
    """
    å‰å‘è¿åŠ¨å­¦
    :param v_left: å·¦è½®é€Ÿåº¦ (m/s)
    :param v_right: å³è½®é€Ÿåº¦ (m/s)
    :param wheelbase: è½®è· (m)
    :return: çº¿é€Ÿåº¦, è§’é€Ÿåº¦
    """
    v_linear = (v_left + v_right) / 2
    Ï‰_angular = (v_right - v_left) / wheelbase

    return v_linear, Ï‰_angular
```

### é€†å‘è¿åŠ¨å­¦

ç»™å®šçº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ï¼Œè®¡ç®—å·¦å³è½®é€Ÿåº¦ï¼š

```python
def inverse_kinematics(v_linear, Ï‰_angular, wheelbase):
    """
    é€†å‘è¿åŠ¨å­¦
    :param v_linear: çº¿é€Ÿåº¦ (m/s)
    :param Ï‰_angular: è§’é€Ÿåº¦ (rad/s)
    :param wheelbase: è½®è· (m)
    :return: å·¦è½®é€Ÿåº¦, å³è½®é€Ÿåº¦
    """
    v_left = v_linear - (Ï‰_angular * wheelbase) / 2
    v_right = v_linear + (Ï‰_angular * wheelbase) / 2

    return v_left, v_right
```

---

## âš™ï¸ PIDæ§åˆ¶

### PIDæ§åˆ¶å™¨åŸç†

```python
class PIDController:
    def __init__(self, kp, ki, kd, output_limits=(None, None)):
        """
        PIDæ§åˆ¶å™¨
        :param kp: æ¯”ä¾‹å¢ç›Š
        :param ki: ç§¯åˆ†å¢ç›Š
        :param kd: å¾®åˆ†å¢ç›Š
        :param output_limits: è¾“å‡ºé™åˆ¶ (min, max)
        """
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.output_limits = output_limits

        self.prev_error = 0
        self.integral = 0

    def compute(self, setpoint, measured_value, dt):
        """
        è®¡ç®—PIDè¾“å‡º
        :param setpoint: ç›®æ ‡å€¼
        :param measured_value: æµ‹é‡å€¼
        :param dt: æ—¶é—´æ­¥é•¿ (s)
        :return: æ§åˆ¶è¾“å‡º
        """
        error = setpoint - measured_value

        # æ¯”ä¾‹é¡¹
        p_term = self.kp * error

        # ç§¯åˆ†é¡¹
        self.integral += error * dt
        i_term = self.ki * self.integral

        # å¾®åˆ†é¡¹
        derivative = (error - self.prev_error) / dt
        d_term = self.kd * derivative

        # PIDè¾“å‡º
        output = p_term + i_term + d_term

        # é™åˆ¶è¾“å‡ºèŒƒå›´
        if self.output_limits[0] is not None:
            output = max(self.output_limits[0], output)
        if self.output_limits[1] is not None:
            output = min(self.output_limits[1], output)

        self.prev_error = error
        return output

    def reset(self):
        """é‡ç½®æ§åˆ¶å™¨çŠ¶æ€"""
        self.prev_error = 0
        self.integral = 0
```

### é€Ÿåº¦æ§åˆ¶ç¤ºä¾‹

```python
# é€Ÿåº¦PIDæ§åˆ¶å™¨
velocity_pid = PIDController(
    kp=1.0,   # æ¯”ä¾‹å¢ç›Š
    ki=0.5,   # ç§¯åˆ†å¢ç›Š
    kd=0.1,   # å¾®åˆ†å¢ç›Š
    output_limits=(-1.0, 1.0)  # PWMè¾“å‡ºèŒƒå›´ -1.0~1.0
)

# æ§åˆ¶å¾ªç¯
def velocity_control_loop(target_velocity, current_velocity, dt):
    # è®¡ç®—PIDè¾“å‡º
    control_output = velocity_pid.compute(target_velocity, current_velocity, dt)

    # å°†æ§åˆ¶è¾“å‡ºè½¬æ¢ä¸ºPWMä¿¡å·
    pwm = control_output * 255  # å‡è®¾PWMèŒƒå›´ 0-255

    return pwm
```

---

## ğŸ§­ çŠ¶æ€ä¼°è®¡

### ç¼–ç¨‹å™¨é‡Œç¨‹è®¡

```python
import numpy as np

class Odometry:
    def __init__(self, wheelbase, wheel_radius, ticks_per_rev):
        """
        é‡Œç¨‹è®¡çŠ¶æ€ä¼°è®¡
        :param wheelbase: è½®è· (m)
        :param wheel_radius: è½®å­åŠå¾„ (m)
        :param ticks_per_rev: ç¼–ç å™¨æ¯åœˆè„‰å†²æ•°
        """
        self.wheelbase = wheelbase
        self.wheel_radius = wheel_radius
        self.ticks_per_rev = ticks_per_rev

        # æœºå™¨äººä½å§¿ [x, y, theta]
        self.pose = np.array([0.0, 0.0, 0.0])

        # ä¸Šä¸€æ—¶åˆ»ç¼–ç å™¨å€¼
        self.prev_left_ticks = 0
        self.prev_right_ticks = 0

    def ticks_to_meters(self, ticks):
        """å°†ç¼–ç å™¨è„‰å†²æ•°è½¬æ¢ä¸ºç±³"""
        meters_per_tick = (2 * np.pi * self.wheel_radius) / self.ticks_per_rev
        return ticks * meters_per_tick

    def update(self, left_ticks, right_ticks, dt):
        """
        æ›´æ–°é‡Œç¨‹è®¡
        :param left_ticks: å·¦è½®ç¼–ç å™¨å€¼
        :param right_ticks: å³è½®ç¼–ç å™¨å€¼
        :param dt: æ—¶é—´æ­¥é•¿ (s)
        """
        # è®¡ç®—ç¼–ç å™¨å¢é‡
        delta_left = left_ticks - self.prev_left_ticks
        delta_right = right_ticks - self.prev_right_ticks

        # è½¬æ¢ä¸ºè·ç¦»
        dist_left = self.ticks_to_meters(delta_left)
        dist_right = self.ticks_to_meters(delta_right)

        # æ›´æ–°ä¸Šä¸€æ—¶åˆ»ç¼–ç å™¨å€¼
        self.prev_left_ticks = left_ticks
        self.prev_right_ticks = right_ticks

        # è®¡ç®—çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦
        v_linear = (dist_left + dist_right) / (2 * dt)
        Ï‰_angular = (dist_right - dist_left) / (self.wheelbase * dt)

        # æ›´æ–°ä½å§¿ï¼ˆå‡è®¾åŒ€é€Ÿè¿åŠ¨ï¼‰
        x, y, theta = self.pose

        # ä½ç½®æ›´æ–°
        if abs(Ï‰_angular) < 0.001:  # ç›´çº¿è¿åŠ¨
            x += v_linear * np.cos(theta) * dt
            y += v_linear * np.sin(theta) * dt
        else:  # åœ†å¼§è¿åŠ¨
            x += (v_linear / Ï‰_angular) * (np.sin(theta + Ï‰_angular * dt) - np.sin(theta))
            y += (v_linear / Ï‰_angular) * (-np.cos(theta + Ï‰_angular * dt) + np.cos(theta))
            theta += Ï‰_angular * dt

        self.pose = np.array([x, y, theta])
        return v_linear, Ï‰_angular, self.pose
```

---

## ğŸ§± IMUæ•°æ®èåˆ

### å§¿æ€ä¼°è®¡

```python
class IMUFusion:
    def __init__(self):
        """IMUæ•°æ®èåˆ"""
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0

    def update_accelerometer(self, ax, ay, az):
        """
        ä»åŠ é€Ÿåº¦è®¡è®¡ç®—rollå’Œpitch
        :param ax, ay, az: åŠ é€Ÿåº¦è®¡æ•°æ® (m/s^2)
        """
        self.roll = np.arctan2(ay, az)
        self.pitch = np.arctan2(-ax, np.sqrt(ay**2 + az**2))

    def update_gyroscope(self, gx, gy, gz, dt):
        """
        ä»é™€èºä»ªç§¯åˆ†è®¡ç®—è§’é€Ÿåº¦
        :param gx, gy, gz: é™€èºä»ªæ•°æ® (rad/s)
        :param dt: æ—¶é—´æ­¥é•¿ (s)
        """
        self.roll += gx * dt
        self.pitch += gy * dt
        self.yaw += gz * dt

    def complementary_filter(self, ax, ay, az, gx, gy, gz, dt, alpha=0.95):
        """
        äº’è¡¥æ»¤æ³¢å™¨èåˆåŠ é€Ÿåº¦è®¡å’Œé™€èºä»ª
        :param alpha: é™€èºä»ªæƒé‡ (0-1)
        """
        # åŠ é€Ÿåº¦è®¡è®¡ç®—rollå’Œpitch
        accel_roll = np.arctan2(ay, az)
        accel_pitch = np.arctan2(-ax, np.sqrt(ay**2 + az**2))

        # äº’è¡¥æ»¤æ³¢
        self.roll = alpha * (self.roll + gx * dt) + (1 - alpha) * accel_roll
        self.pitch = alpha * (self.pitch + gy * dt) + (1 - alpha) * accel_pitch
        self.yaw += gz * dt  # åèˆªè§’ä»…ä½¿ç”¨é™€èºä»ª
```

---

## ğŸ¯ æ ‡å®š

### é€Ÿåº¦æ ‡å®š

```python
class VelocityCalibration:
    def __init__(self):
        self.measurements = []

    def collect(self, pwm_command, actual_velocity):
        """
        æ”¶é›†æ ‡å®šæ•°æ®
        :param pwm_command: PWMå‘½ä»¤å€¼
        :param actual_velocity: å®é™…é€Ÿåº¦ (m/s)
        """
        self.measurements.append({
            'pwm': pwm_command,
            'velocity': actual_velocity
        })

    def fit_model(self):
        """
        æ‹ŸåˆPWM-é€Ÿåº¦æ¨¡å‹
        :return: çº¿æ€§æ¨¡å‹å‚æ•° (slope, intercept)
        """
        import numpy as np

        # æå–æ•°æ®
        pwm = np.array([m['pwm'] for m in self.measurements])
        velocity = np.array([m['velocity'] for m in self.measurements])

        # çº¿æ€§æ‹Ÿåˆ: velocity = slope * pwm + intercept
        coeffs = np.polyfit(pwm, velocity, 1)
        slope, intercept = coeffs

        return slope, intercept

    def pwm_to_velocity(self, pwm, slope, intercept):
        """PWMè½¬é€Ÿåº¦"""
        return slope * pwm + intercept

    def velocity_to_pwm(self, velocity, slope, intercept):
        """é€Ÿåº¦è½¬PWM"""
        return (velocity - intercept) / slope
```

---

## ğŸ“¡ ä¼ æ„Ÿå™¨é›†æˆ

### æ¿€å…‰é›·è¾¾

```python
from sensor_msgs.msg import LaserScan

def scan_callback(msg):
    """
    æ¿€å…‰é›·è¾¾æ•°æ®å¤„ç†
    """
    angle_min = msg.angle_min
    angle_increment = msg.angle_increment
    ranges = msg.ranges

    # å¤„ç†ç‚¹äº‘æ•°æ®
    points = []
    for i, range_val in enumerate(ranges):
        if range_val < msg.range_max and range_val > msg.range_min:
            angle = angle_min + i * angle_increment
            x = range_val * np.cos(angle)
            y = range_val * np.sin(angle)
            points.append([x, y])

    return points
```

---

## ğŸ—ºï¸ åæ ‡å˜æ¢ (TF2)

### TFæ ‘

```
/base_footprint
    â””â”€â”€ /base_link
            â”œâ”€â”€ /laser_link
            â”œâ”€â”€ /camera_link
            â””â”€â”€ /imu_link
```

### TF2ä½¿ç”¨

```python
import rclpy
from rclpy.node import Node
from tf2_ros import TransformListener, Buffer
from tf2_ros import TransformException

class TFListener(Node):
    def __init__(self):
        super().__init__('tf_listener')
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        self.timer = self.create_timer(0.1, self.on_timer)

    def on_timer(self):
        try:
            # è·å–åæ ‡å˜æ¢
            transform = self.tf_buffer.lookup_transform(
                'base_link',
                'laser_link',
                rclpy.time.Time())

            self.get_logger().info(
                f'Transform: {transform.transform.translation.x}, '
                f'{transform.transform.translation.y}, '
                f'{transform.transform.translation.z}')

        except TransformException as ex:
            self.get_logger().error(f'TF error: {ex}')
```

---

## ğŸ“š æœºå™¨äººæ§åˆ¶å®è·µ

> ä»ç†è®ºåˆ°å®è·µçš„å®Œæ•´æœºå™¨äººæ§åˆ¶æŒ‡å—

### å¼€å‘å‰çš„å‡†å¤‡

| å®è·µ | æè¿° |
| --- | --- |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/01-å¼€å‘å‰çš„å‡†å¤‡/çƒ§å½•å‡ºå‚å›ºä»¶]] | å›ºä»¶çƒ§å½•æ­¥éª¤ |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/01-å¼€å‘å‰çš„å‡†å¤‡/è¿æ¥microROSä»£ç†]] | ä»£ç†è¿æ¥é…ç½® |

### æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹

| å®è·µ | æè¿° |
| --- | --- |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/æœºå™¨äººä¿¡æ¯å‘å¸ƒ]] | ä¼ æ„Ÿå™¨æ•°æ®å‘å¸ƒä¸æŸ¥è¯¢ |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/æœºå™¨äººé”®ç›˜æ§åˆ¶]] | é”®ç›˜æ§åˆ¶æœºå™¨äºº |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/æœºå™¨äººæ‰‹æŸ„æ§åˆ¶]] | æ‰‹æŸ„æ§åˆ¶æœºå™¨äºº |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/æœºå™¨äººçŠ¶æ€ä¼°è®¡]] | çŠ¶æ€ä¼°è®¡ç®—æ³• |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/çº¿é€Ÿåº¦æ ‡å®š]] | çº¿é€Ÿåº¦æ ¡å‡† |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/è§’é€Ÿåº¦æ ‡å®š]] | è§’é€Ÿåº¦æ ¡å‡† |
| [[ESP32ä¾‹ç¨‹é›†/08-æœºå™¨äººæ§åˆ¶/02-æœºå™¨äººæ§åˆ¶æ¡ˆä¾‹/æœºå™¨äººURDFæ¨¡å‹]] | URDFæ¨¡å‹æ–‡ä»¶ |

---

## ğŸ”— ç›¸å…³èµ„æº

### ç›¸å…³ç¬”è®°
- [[MicroROS-Boardå­¦ä¹ é¡¹ç›®]] - å­¦ä¹ é¡¹ç›®
- [[ROS2åŸºç¡€æ¦‚å¿µ]] - ROS2æ ¸å¿ƒæ¦‚å¿µ
- [[ESP32å¼€å‘åŸºç¡€]] - åµŒå…¥å¼å¼€å‘

### å‚è€ƒèµ„æ–™
- Probabilistic Robotics - Thrun
- Introduction to Robotics: Mechanics and Control - Craig

---

*åˆ†ç±»: 3 Resources*
*åˆ›å»ºæ—¶é—´: 2026-02-19*
