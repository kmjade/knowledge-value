---
title: æ’ä»¶å®‰å…¨è§„èŒƒ
status: active
priority: high
tags: [clawdbot, security, plugins, best-practices]
aliases: [æ’ä»¶å®‰å…¨, Security Guide]
created: 2026-01-31
modified: 2026-01-31
---

# æ’ä»¶å®‰å…¨è§„èŒƒ

> æœ¬æ–‡æ¡£å®šä¹‰äº† ClawdBot æ’ä»¶å¼€å‘çš„å®‰å…¨æ ‡å‡†ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºå®‰å…¨å¯é çš„æ’ä»¶ã€‚

## ğŸ“‹ ç›®å½•

- [å®‰å…¨åŸåˆ™](#å®‰å…¨åŸåˆ™)
- [æƒé™ç®¡ç†](#æƒé™ç®¡ç†)
- [ä»£ç å®‰å…¨](#ä»£ç å®‰å…¨)
- [æ•°æ®å®‰å…¨](#æ•°æ®å®‰å…¨)
- [é€šä¿¡å®‰å…¨](#é€šä¿¡å®‰å…¨)
- [ä¾èµ–å®‰å…¨](#ä¾èµ–å®‰å…¨)
- [å®¡è®¡ä¸ç›‘æ§](#å®¡è®¡ä¸ç›‘æ§)
- [å®‰å…¨æµ‹è¯•](#å®‰å…¨æµ‹è¯•)
- [åº”æ€¥å“åº”](#åº”æ€¥å“åº”)

---

## å®‰å…¨åŸåˆ™

### æ ¸å¿ƒå®‰å…¨åŸåˆ™

1. **æœ€å°æƒé™åŸåˆ™**
   - æ’ä»¶åªåº”è¯·æ±‚å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
   - é™åˆ¶å¯¹ç³»ç»Ÿèµ„æºã€ç½‘ç»œã€æ–‡ä»¶çš„è®¿é—®

2. **çºµæ·±é˜²å¾¡**
   - å¤šå±‚å®‰å…¨é˜²æŠ¤ï¼šè¾“å…¥éªŒè¯ â†’ æƒé™æ£€æŸ¥ â†’ æ²™ç®±éš”ç¦» â†’ å®¡è®¡æ—¥å¿—

3. **é›¶ä¿¡ä»»**
   - ä¸ä¿¡ä»»ä»»ä½•å¤–éƒ¨è¾“å…¥
   - éªŒè¯æ‰€æœ‰æ¥è‡ªç”¨æˆ·ã€APIã€æ’ä»¶çš„æ•°æ®

4. **å®‰å…¨é»˜è®¤**
   - é»˜è®¤é…ç½®åº”è¯¥æ˜¯å®‰å…¨çš„
   - æ•æ„Ÿæ“ä½œéœ€è¦æ˜¾å¼æˆæƒ

### å®‰å…¨æˆç†Ÿåº¦æ¨¡å‹

```
çº§åˆ« 1: åŸºç¡€å®‰å…¨
â”œâ”€ è¾“å…¥éªŒè¯
â”œâ”€ é”™è¯¯å¤„ç†
â””â”€ åŸºæœ¬æ—¥å¿—

çº§åˆ« 2: æ ‡å‡†å®‰å…¨
â”œâ”€ æƒé™æ§åˆ¶
â”œâ”€ æ•°æ®åŠ å¯†
â”œâ”€ ä¾èµ–æ‰«æ
â””â”€ å®‰å…¨å®¡è®¡

çº§åˆ« 3: é«˜çº§å®‰å…¨
â”œâ”€ æ²™ç®±éš”ç¦»
â”œâ”€ æŒç»­ç›‘æ§
â”œâ”€ å®‰å…¨æµ‹è¯•è‡ªåŠ¨åŒ–
â””â”€ åº”æ€¥å“åº”æµç¨‹

çº§åˆ« 4: ä¼ä¸šçº§å®‰å…¨
â”œâ”€ å®šæœŸå®‰å…¨å®¡è®¡
â”œâ”€ æ¸—é€æµ‹è¯•
â”œâ”€ åˆè§„æ€§æ£€æŸ¥
â””â”€ å®‰å…¨åŸ¹è®­
```

---

## æƒé™ç®¡ç†

### æƒé™å£°æ˜

åœ¨ `manifest.yaml` ä¸­æ˜ç¡®å£°æ˜æ‰€éœ€æƒé™ï¼š

```yaml
# manifest.yaml
permissions:
  # ç½‘ç»œè®¿é—®æƒé™
  network:
    allowed_hosts:
      - "api.example.com:443"
      - "cdn.example.com:443"
    blocked_hosts:
      - "localhost"
      - "internal.company.local"
    blocked_ports: [22, 23, 8080]

  # æ–‡ä»¶ç³»ç»Ÿè®¿é—®
  filesystem:
    read:
      - "./config/*"
      - "./templates/*"
    write:
      - "./logs/*"
      - "./cache/*"
    denied:
      - "/etc/*"
      - "/root/*"
      - "/home/*"

  # ç¯å¢ƒå˜é‡è®¿é—®
  environment:
    - "API_KEY"
    - "DATABASE_URL"
    - "SECRET_KEY"

  # æ•°æ®åº“è®¿é—®
  database:
    tables:
      read: ["users", "logs"]
      write: ["logs"]
    denied_tables: ["admin_users", "system_config"]

  # ç³»ç»Ÿå‘½ä»¤æ‰§è¡Œ
  system:
    allowed_commands:
      - "date"
      - "echo"
    denied_commands: ["rm", "sudo", "bash"]
```

### æƒé™éªŒè¯

```python
from clawdbot.security import PermissionChecker, SecurityError

class SecurePlugin(BasePlugin):
    def __init__(self, config):
        super().__init__(config)
        self.permission_checker = PermissionChecker()

    async def execute(self, inputs, context):
        # éªŒè¯æ‰§è¡Œæƒé™
        if not await self.permission_checker.check_permission(
            plugin_id=self.metadata["name"],
            action="execute",
            context=context
        ):
            raise SecurityError("æƒé™ä¸è¶³ï¼Œæ— æ³•æ‰§è¡Œæ­¤æ“ä½œ")

        # éªŒè¯æ•°æ®è®¿é—®æƒé™
        if "user_id" in inputs:
            if not await self.permission_checker.can_access_user_data(
                context.user_id,
                inputs["user_id"]
            ):
                raise SecurityError("æ— æƒè®¿é—®å…¶ä»–ç”¨æˆ·çš„æ•°æ®")

        # æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        result = await self.process_data(inputs)
        return result
```

### æƒé™å®¡è®¡

```python
class PermissionAuditor:
    """æƒé™å®¡è®¡å™¨"""

    async def audit_plugin_permissions(self, plugin_id: str):
        """å®¡è®¡æ’ä»¶æƒé™ä½¿ç”¨æƒ…å†µ"""

        # è·å–æ’ä»¶å£°æ˜çš„æƒé™
        declared_perms = await self.get_declared_permissions(plugin_id)

        # è·å–å®é™…ä½¿ç”¨çš„æƒé™
        used_perms = await self.get_used_permissions(plugin_id)

        # æ£€æŸ¥æœªå£°æ˜çš„æƒé™ä½¿ç”¨
        undeclared = used_perms - declared_perms

        # æ£€æŸ¥æœªä½¿ç”¨çš„æƒé™å£°æ˜
        unused = declared_perms - used_perms

        report = {
            "plugin_id": plugin_id,
            "declared_permissions": list(declared_perms),
            "used_permissions": list(used_perms),
            "undeclared_usage": list(undeclared),
            "unused_declarations": list(unused),
            "compliance_score": self.calculate_compliance_score(declared_perms, used_perms)
        }

        return report
```

---

## ä»£ç å®‰å…¨

### è¾“å…¥éªŒè¯

```python
import re
from pydantic import BaseModel, validator, Field
from typing import List

class UserInputModel(BaseModel):
    """ç”¨æˆ·è¾“å…¥æ¨¡å‹"""

    email: str = Field(..., description="ç”¨æˆ·é‚®ç®±")
    username: str = Field(..., min_length=3, max_length=50)
    message: str = Field(..., max_length=1000)
    age: int = Field(..., ge=0, le=150)

    @validator('email')
    def validate_email(cls, v):
        """éªŒè¯é‚®ç®±æ ¼å¼"""
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', v):
            raise ValueError('æ— æ•ˆçš„é‚®ç®±æ ¼å¼')
        return v.lower()  # è§„èŒƒåŒ–é‚®ç®±

    @validator('username')
    def validate_username(cls, v):
        """éªŒè¯ç”¨æˆ·å"""
        if not re.match(r'^[a-zA-Z0-9_-]+$', v):
            raise ValueError('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦')
        return v

    @validator('message')
    def sanitize_message(cls, v):
        """æ¸…ç†æ¶ˆæ¯å†…å®¹"""
        # ç§»é™¤å±é™©å­—ç¬¦
        dangerous_patterns = [
            r'<script.*?>.*?</script>',  # XSS
            r'javascript:',              # JSä¼ªåè®®
            r'on\w+\s*=',               # äº‹ä»¶å¤„ç†å™¨
        ]

        for pattern in dangerous_patterns:
            v = re.sub(pattern, '', v, flags=re.IGNORECASE)

        return v

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # éªŒè¯è¾“å…¥
        try:
            validated = UserInputModel(**inputs)
        except ValueError as e:
            raise ValidationError(f"è¾“å…¥éªŒè¯å¤±è´¥: {e}")

        # ä½¿ç”¨éªŒè¯åçš„æ•°æ®
        result = await self.process(validated)
        return result
```

### é˜²æ­¢æ³¨å…¥æ”»å‡»

#### SQL æ³¨å…¥é˜²æŠ¤

```python
# âŒ å±é™©ï¼šSQL æ³¨å…¥é£é™©
async def unsafe_query(user_id: str):
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    return await db.execute(query)

# âœ… å®‰å…¨ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
async def safe_query(user_id: str):
    query = "SELECT * FROM users WHERE id = %s"
    return await db.execute(query, [user_id])

# âœ… æ›´å®‰å…¨ï¼šä½¿ç”¨ ORM
async def safe_query_with_orm(user_id: str):
    return await User.objects.filter(id=user_id).all()
```

#### å‘½ä»¤æ³¨å…¥é˜²æŠ¤

```python
import subprocess
import shlex

class CommandExecutor:
    def __init__(self, allowed_commands: List[str]):
        self.allowed_commands = set(allowed_commands)

    async def safe_execute(self, command: str, args: List[str]):
        """å®‰å…¨æ‰§è¡Œå‘½ä»¤"""
        # 1. éªŒè¯å‘½ä»¤æ˜¯å¦åœ¨ç™½åå•ä¸­
        if command not in self.allowed_commands:
            raise SecurityError(f"ä¸å…è®¸æ‰§è¡Œçš„å‘½ä»¤: {command}")

        # 2. è½¬ä¹‰å‚æ•°
        safe_args = [shlex.quote(arg) for arg in args]

        # 3. æ„å»ºå®‰å…¨å‘½ä»¤
        safe_command = f"{command} {' '.join(safe_args)}"

        # 4. æ‰§è¡Œï¼ˆä½¿ç”¨ subprocess è€Œé os.systemï¼‰
        result = subprocess.run(
            safe_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )

        return result.stdout
```

#### XSS é˜²æŠ¤

```python
import html
from markupsafe import escape

class XSSProtection:
    @staticmethod
    def sanitize_user_input(text: str) -> str:
        """æ¸…ç†ç”¨æˆ·è¾“å…¥ï¼Œé˜²æ­¢ XSS"""
        # è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦
        escaped = html.escape(text)

        # ç§»é™¤å±é™©æ ‡ç­¾
        dangerous_tags = ['<script', '<iframe', '<object', '<embed']
        for tag in dangerous_tags:
            escaped = escaped.replace(tag, f"&lt;{tag[1:]}")

        return escaped

    @staticmethod
    def safe_render(template: str, context: dict) -> str:
        """å®‰å…¨æ¸²æŸ“æ¨¡æ¿"""
        # ä½¿ç”¨ Jinja2 çš„è‡ªåŠ¨è½¬ä¹‰
        from jinja2 import Template

        template = Template(template, autoescape=True)
        return template.render(**context)
```

### å¯†é’¥ç®¡ç†

```python
import os
import base64
from cryptography.fernet import Fernet
from typing import Optional

class SecureCredentials:
    """å®‰å…¨å‡­è¯ç®¡ç†å™¨"""

    def __init__(self):
        # ä»ç¯å¢ƒå˜é‡è¯»å–åŠ å¯†å¯†é’¥
        encryption_key = os.getenv("ENCRYPTION_KEY")
        if not encryption_key:
            raise ValueError("æœªè®¾ç½® ENCRYPTION_KEY ç¯å¢ƒå˜é‡")

        self.cipher = Fernet(encryption_key.encode())

    def encrypt(self, plaintext: str) -> str:
        """åŠ å¯†æ•°æ®"""
        encrypted = self.cipher.encrypt(plaintext.encode())
        return base64.b64encode(encrypted).decode()

    def decrypt(self, ciphertext: str) -> str:
        """è§£å¯†æ•°æ®"""
        encrypted = base64.b64decode(ciphertext.encode())
        decrypted = self.cipher.decrypt(encrypted)
        return decrypted.decode()

    def get_api_key(self, service: str) -> str:
        """è·å– API å¯†é’¥"""
        # ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–
        env_key = f"{service.upper()}_API_KEY"
        key = os.getenv(env_key)

        if key:
            return key

        # ä»åŠ å¯†å­˜å‚¨è¯»å–
        from clawdbot.storage import SecretStorage
        storage = SecretStorage()
        encrypted_key = storage.get(f"{service}.key")

        if encrypted_key:
            return self.decrypt(encrypted_key)

        raise ValueError(f"æœªæ‰¾åˆ° {service} çš„ API å¯†é’¥")

# ä½¿ç”¨ç¤ºä¾‹
credentials = SecureCredentials()

class SecurePlugin(BasePlugin):
    def __init__(self, config):
        super().__init__(config)
        self.credentials = SecureCredentials()
        self.api_key = self.credentials.get_api_key("example_service")
```

---

## æ•°æ®å®‰å…¨

### æ•°æ®åŠ å¯†

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import os

class DataEncryption:
    """æ•°æ®åŠ å¯†å·¥å…·"""

    def __init__(self, password: str):
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        salt = b'salt_'  # å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨éšæœºç›
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        self.key = kdf.derive(password.encode())
        self.cipher = Fernet(Fernet.generate_key())  # ä½¿ç”¨ç”Ÿæˆçš„å¯†é’¥

    def encrypt_sensitive_field(self, field_name: str, value: str) -> str:
        """åŠ å¯†æ•æ„Ÿå­—æ®µ"""
        # åªåŠ å¯†æŒ‡å®šçš„æ•æ„Ÿå­—æ®µ
        sensitive_fields = ['password', 'token', 'secret', 'credit_card']

        if field_name.lower() in sensitive_fields:
            return self.cipher.encrypt(value.encode()).decode()

        return value

    def decrypt_sensitive_field(self, field_name: str, encrypted_value: str) -> str:
        """è§£å¯†æ•æ„Ÿå­—æ®µ"""
        sensitive_fields = ['password', 'token', 'secret', 'credit_card']

        if field_name.lower() in sensitive_fields:
            decrypted = self.cipher.decrypt(encrypted_value.encode())
            return decrypted.decode()

        return encrypted_value
```

### æ•æ„Ÿæ•°æ®å¤„ç†

```python
class SensitiveDataHandler:
    """æ•æ„Ÿæ•°æ®å¤„ç†å™¨"""

    @staticmethod
    def mask_data(data: dict, sensitive_fields: List[str]) -> dict:
        """é®è”½æ•æ„Ÿæ•°æ®"""
        masked = data.copy()

        for field in sensitive_fields:
            if field in masked:
                value = str(masked[field])
                # åªæ˜¾ç¤ºå‰å2ä½ï¼Œä¸­é—´ç”¨ * ä»£æ›¿
                if len(value) > 4:
                    masked[field] = value[:2] + '*' * (len(value) - 4) + value[-2:]
                else:
                    masked[field] = '***'

        return masked

    @staticmethod
    def should_log_data(data: dict) -> dict:
        """å‡†å¤‡ç”¨äºæ—¥å¿—çš„æ•°æ®"""
        # ç§»é™¤æˆ–é®è”½æ•æ„Ÿå­—æ®µ
        sensitive_fields = [
            'password', 'token', 'secret',
            'credit_card', 'ssn', 'api_key'
        ]

        return SensitiveDataHandler.mask_data(data, sensitive_fields)

# ä½¿ç”¨ç¤ºä¾‹
handler = SensitiveDataHandler()

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # å¤„ç†æ•æ„Ÿæ•°æ®
        self.logger.info(
            "å¤„ç†è¯·æ±‚",
            extra=handler.should_log_data(inputs)
        )

        # ä¸è¦è®°å½•å®Œæ•´æ•°æ®
        self.logger.info(f"è¯·æ±‚ID: {context.task_id}")  # å®‰å…¨
        self.logger.info(f"è¯·æ±‚æ•°æ®: {inputs}")  # ä¸å®‰å…¨ï¼

        result = await self.process(inputs)
        return result
```

---

## é€šä¿¡å®‰å…¨

### HTTPS/TLS é…ç½®

```python
import ssl
import aiohttp

class SecureHTTPClient:
    """å®‰å…¨çš„ HTTP å®¢æˆ·ç«¯"""

    def __init__(self):
        self.ssl_context = ssl.create_default_context()
        self.ssl_context.verify_mode = ssl.CERT_REQUIRED
        self.ssl_context.check_hostname = True

    async def get(self, url: str, headers: dict = None):
        """å®‰å…¨ GET è¯·æ±‚"""
        async with aiohttp.ClientSession() as session:
            async with session.get(
                url,
                ssl=self.ssl_context,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                if response.status != 200:
                    raise HTTPError(f"è¯·æ±‚å¤±è´¥: {response.status}")

                return await response.json()

    async def post(self, url: str, data: dict, headers: dict = None):
        """å®‰å…¨ POST è¯·æ±‚"""
        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                json=data,
                ssl=self.ssl_context,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                if response.status != 200:
                    raise HTTPError(f"è¯·æ±‚å¤±è´¥: {response.status}")

                return await response.json()

# ä½¿ç”¨ç¤ºä¾‹
client = SecureHTTPClient()

class SecurePlugin(BasePlugin):
    async def execute(self, inputs, context):
        # ä½¿ç”¨å®‰å…¨å®¢æˆ·ç«¯
        result = await client.post(
            "https://api.example.com/data",
            data=inputs,
            headers={"Authorization": f"Bearer {self.api_key}"}
        )

        return PluginResult(success=True, data=result)
```

### API å®‰å…¨

```python
import hashlib
import hmac
import time
from typing import Dict

class APISecurity:
    """API å®‰å…¨å·¥å…·"""

    @staticmethod
    def generate_signature(
        method: str,
        url: str,
        params: Dict,
        secret_key: str
    ) -> str:
        """ç”Ÿæˆ API ç­¾å"""
        # 1. å°†å‚æ•°æŒ‰å­—æ¯é¡ºåºæ’åº
        sorted_params = sorted(params.items())

        # 2. æ„å»ºç­¾åå­—ç¬¦ä¸²
        sign_string = f"{method.upper()}&{url}&" + "&".join(
            f"{k}={v}" for k, v in sorted_params
        )

        # 3. ä½¿ç”¨ HMAC-SHA256 ç”Ÿæˆç­¾å
        signature = hmac.new(
            secret_key.encode(),
            sign_string.encode(),
            hashlib.sha256
        ).hexdigest()

        return signature

    @staticmethod
    def validate_signature(
        received_signature: str,
        method: str,
        url: str,
        params: Dict,
        secret_key: str
    ) -> bool:
        """éªŒè¯ API ç­¾å"""
        expected_signature = APISecurity.generate_signature(
            method, url, params, secret_key
        )
        return hmac.compare_digest(received_signature, expected_signature)

# ä½¿ç”¨ç¤ºä¾‹
security = APISecurity()

class SecureAPIPlugin(BasePlugin):
    async def call_external_api(self, endpoint: str, data: dict):
        """è°ƒç”¨å¤–éƒ¨ APIï¼ˆå¸¦ç­¾åï¼‰"""
        params = {
            **data,
            "timestamp": int(time.time()),
            "nonce": self.generate_nonce()
        }

        signature = security.generate_signature(
            "POST",
            endpoint,
            params,
            self.api_secret
        )

        result = await self.http_client.post(
            endpoint,
            data={**params, "signature": signature}
        )

        return result
```

---

## ä¾èµ–å®‰å…¨

### ä¾èµ–æ¼æ´æ‰«æ

```bash
# å®‰è£…å®‰å…¨æ‰«æå·¥å…·
pip install safety bandit

# æ‰«æå·²çŸ¥æ¼æ´
safety check

# é™æ€ä»£ç åˆ†æ
bandit -r my_plugin/

# æ£€æŸ¥è¿‡æœŸä¾èµ–
pip list --outdated
```

### ä¾èµ–ç™½åå•

```python
# requirements-safety.txt
# åªåŒ…å«ç»è¿‡å®‰å…¨å®¡è®¡çš„ä¾èµ–

# æ ¸å¿ƒä¾èµ–
cryptography>=41.0.0
pydantic>=2.0.0
aiohttp>=3.8.0

# å®‰å…¨å·¥å…·
bandit>=1.7.0
safety>=2.3.0
```

### ä¾èµ–æ›´æ–°ç­–ç•¥

```python
import subprocess
import re
from typing import List, Dict

class DependencyManager:
    """ä¾èµ–ç®¡ç†å™¨"""

    async def check_for_vulnerabilities(self) -> Dict[str, List[str]]:
        """æ£€æŸ¥ä¾èµ–æ¼æ´"""
        vulnerabilities = {}

        # è¿è¡Œ safety check
        result = subprocess.run(
            ["safety", "check", "--json"],
            capture_output=True,
            text=True
        )

        if result.stdout:
            import json
            report = json.loads(result.stdout)
            vulnerabilities = {
                vuln["package"]: vuln.get("affected_versions", [])
                for vuln in report
            }

        return vulnerabilities

    async def auto_update_secure(self, package: str):
        """è‡ªåŠ¨æ›´æ–°åˆ°å®‰å…¨ç‰ˆæœ¬"""
        # æ£€æŸ¥å¯ç”¨ç‰ˆæœ¬
        versions = await self.get_available_versions(package)

        # é€‰æ‹©æœ€æ–°å®‰å…¨ç‰ˆæœ¬
        safe_version = self.select_safe_version(package, versions)

        if safe_version:
            # æ›´æ–°ä¾èµ–
            subprocess.run(
                ["pip", "install", "--upgrade", f"{package}=={safe_version}"],
                check=True
            )
            return True

        return False
```

---

## å®¡è®¡ä¸ç›‘æ§

### æ“ä½œæ—¥å¿—

```python
import json
from datetime import datetime
from typing import Dict, Any

class SecurityAuditLogger:
    """å®‰å…¨å®¡è®¡æ—¥å¿—å™¨"""

    def __init__(self, log_file: str):
        self.log_file = log_file

    def log_security_event(
        self,
        event_type: str,
        plugin_id: str,
        user_id: str,
        details: Dict[str, Any]
    ):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": event_type,
            "plugin_id": plugin_id,
            "user_id": user_id,
            "ip_address": self.get_client_ip(),
            "user_agent": self.get_user_agent(),
            "details": self.sanitize_details(details)
        }

        # å†™å…¥æ—¥å¿—æ–‡ä»¶
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + "\n")

    def log_permission_violation(
        self,
        plugin_id: str,
        attempted_action: str,
        required_permission: str
    ):
        """è®°å½•æƒé™è¿è§„"""
        self.log_security_event(
            event_type="PERMISSION_VIOLATION",
            plugin_id=plugin_id,
            user_id=self.get_current_user(),
            details={
                "attempted_action": attempted_action,
                "required_permission": required_permission,
                "severity": "high"
            }
        )

    def sanitize_details(self, details: Dict[str, Any]) -> Dict[str, Any]:
        """æ¸…ç†æ•æ„Ÿä¿¡æ¯"""
        sensitive_keys = ['password', 'token', 'secret', 'api_key']

        sanitized = details.copy()
        for key in sensitive_keys:
            if key in sanitized:
                sanitized[key] = "***REDACTED***"

        return sanitized
```

### å®æ—¶ç›‘æ§

```python
from collections import deque
from datetime import datetime, timedelta
import asyncio

class SecurityMonitor:
    """å®‰å…¨ç›‘æ§å™¨"""

    def __init__(self):
        # ä¿ç•™æœ€è¿‘1000ä¸ªäº‹ä»¶
        self.events = deque(maxlen=1000)
        self.alerts = []

    async def monitor_plugin_activity(self, plugin_id: str):
        """ç›‘æ§æ’ä»¶æ´»åŠ¨"""
        recent_events = self.get_recent_events(plugin_id, minutes=5)

        # æ£€æŸ¥å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
        anomalies = self.detect_anomalies(recent_events)

        if anomalies:
            await self.handle_anomalies(plugin_id, anomalies)

    def detect_anomalies(self, events: list) -> list:
        """æ£€æµ‹å¼‚å¸¸è¡Œä¸º"""
        anomalies = []

        # 1. æ£€æŸ¥è¯·æ±‚é¢‘ç‡å¼‚å¸¸
        request_count = len(events)
        if request_count > 100:  # 5åˆ†é’Ÿå†…è¶…è¿‡100æ¬¡è¯·æ±‚
            anomalies.append({
                "type": "high_request_rate",
                "count": request_count,
                "severity": "medium"
            })

        # 2. æ£€æŸ¥å¤±è´¥ç‡å¼‚å¸¸
        failures = [e for e in events if e.get("success") is False]
        failure_rate = len(failures) / len(events) if events else 0

        if failure_rate > 0.5:  # å¤±è´¥ç‡è¶…è¿‡50%
            anomalies.append({
                "type": "high_failure_rate",
                "rate": failure_rate,
                "severity": "high"
            })

        # 3. æ£€æŸ¥å¼‚å¸¸IP
        ips = set(e.get("ip_address") for e in events)
        if len(ips) > 10:  # æ¥è‡ªè¶…è¿‡10ä¸ªä¸åŒIP
            anomalies.append({
                "type": "multiple_ips",
                "count": len(ips),
                "severity": "low"
            })

        return anomalies

    async def handle_anomalies(self, plugin_id: str, anomalies: list):
        """å¤„ç†å¼‚å¸¸"""
        for anomaly in anomalies:
            if anomaly["severity"] == "high":
                # ä¸¥é‡å¼‚å¸¸ï¼šæš‚åœæ’ä»¶
                await self.suspend_plugin(plugin_id)
                await self.notify_admin(plugin_id, anomaly)
            elif anomaly["severity"] == "medium":
                # ä¸­ç­‰å¼‚å¸¸ï¼šè­¦å‘Š
                await self.send_warning(plugin_id, anomaly)
            else:
                # è½»å¾®å¼‚å¸¸ï¼šè®°å½•
                self.logger.warning(f"æ£€æµ‹åˆ°å¼‚å¸¸: {anomaly}")
```

---

## å®‰å…¨æµ‹è¯•

### å•å…ƒæµ‹è¯•

```python
import pytest
from my_plugin.security import InputValidator

class TestSecurity:
    """å®‰å…¨æµ‹è¯•å¥—ä»¶"""

    def test_sql_injection_protection(self):
        """æµ‹è¯•SQLæ³¨å…¥é˜²æŠ¤"""
        malicious_inputs = [
            "1' OR '1'='1",
            "1'; DROP TABLE users; --",
            "1' UNION SELECT * FROM admin_users; --"
        ]

        validator = InputValidator()

        for input_str in malicious_inputs:
            # åº”è¯¥è¢«æ‹’ç»æˆ–æ¸…ç†
            result = validator.sanitize(input_str)
            assert "DROP TABLE" not in result
            assert "UNION SELECT" not in result

    def test_xss_protection(self):
        """æµ‹è¯•XSSé˜²æŠ¤"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>"
        ]

        validator = InputValidator()

        for payload in xss_payloads:
            result = validator.sanitize(payload)
            assert "<script" not in result
            assert "javascript:" not in result
            assert "onerror=" not in result

    def test_command_injection_protection(self):
        """æµ‹è¯•å‘½ä»¤æ³¨å…¥é˜²æŠ¤"""
        malicious_commands = [
            "; cat /etc/passwd",
            "&& rm -rf /",
            "| ls -la",
            "`whoami`"
        ]

        executor = SecureCommandExecutor(["date"])

        for cmd in malicious_commands:
            # åº”è¯¥è¢«æ‹’ç»
            with pytest.raises(SecurityError):
                executor.execute(cmd)
```

### é›†æˆæµ‹è¯•

```python
@pytest.mark.security
class TestPluginSecurity:
    """æ’ä»¶å®‰å…¨é›†æˆæµ‹è¯•"""

    async def test_permission_enforcement(self):
        """æµ‹è¯•æƒé™å¼ºåˆ¶æ‰§è¡Œ"""
        plugin = MyPlugin({"permissions": []})

        # å°è¯•æ‰§è¡Œéœ€è¦æƒé™çš„æ“ä½œ
        result = await plugin.execute(
            inputs={"action": "admin_only"},
            context=MockContext(user_role="user")
        )

        assert result.success is False
        assert "permission" in result.error.lower()

    async def test_data_leak_prevention(self):
        """æµ‹è¯•æ•°æ®æ³„éœ²é˜²æŠ¤"""
        plugin = MyPlugin({})

        # æ‰§è¡Œå¯èƒ½æ³„éœ²æ•°æ®çš„æ“ä½œ
        result = await plugin.execute(
            inputs={"sensitive_data": "secret"},
            context=MockContext()
        )

        # æ£€æŸ¥æ—¥å¿—ä¸­ä¸åŒ…å«æ•æ„Ÿæ•°æ®
        log_output = self.get_plugin_logs(plugin)
        assert "secret" not in log_output
        assert "***" in log_output  # æ•æ„Ÿæ•°æ®è¢«é®è”½
```

### æ¸—é€æµ‹è¯•

```python
class PenetrationTest:
    """æ¸—é€æµ‹è¯•å·¥å…·"""

    async def test_sql_injection(self, endpoint: str):
        """SQLæ³¨å…¥æµ‹è¯•"""
        payloads = [
            "1' OR '1'='1",
            "1' UNION SELECT username, password FROM users--",
            "1'; DROP TABLE users; --"
        ]

        results = []

        for payload in payloads:
            try:
                response = await self.send_request(endpoint, {"id": payload})
                if "error" not in response.lower():
                    results.append({
                        "payload": payload,
                        "vulnerable": True,
                        "response": response
                    })
            except Exception:
                pass

        return results

    async def test_xss(self, endpoint: str):
        """XSSæµ‹è¯•"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]

        results = []

        for payload in payloads:
            try:
                response = await self.send_request(endpoint, {"input": payload})
                if "<script" in response or "alert" in response:
                    results.append({
                        "payload": payload,
                        "vulnerable": True
                    })
            except Exception:
                pass

        return results
```

---

## åº”æ€¥å“åº”

### å®‰å…¨äº‹ä»¶åˆ†ç±»

```python
from enum import Enum

class SecurityEventType(Enum):
    """å®‰å…¨äº‹ä»¶ç±»å‹"""
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    DATA_LEAK = "data_leak"
    MALICIOUS_CODE = "malicious_code"
    RESOURCE_ABUSE = "resource_abuse"
    PERMISSION_VIOLATION = "permission_violation"
    BRUTE_FORCE = "brute_force"

class SecuritySeverity(Enum):
    """å®‰å…¨äº‹ä»¶ä¸¥é‡æ€§"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
```

### åº”æ€¥å“åº”æµç¨‹

```python
class SecurityIncidentHandler:
    """å®‰å…¨äº‹ä»¶å¤„ç†å™¨"""

    def __init__(self):
        self.handlers = {
            SecuritySeverity.CRITICAL: self.handle_critical,
            SecuritySeverity.HIGH: self.handle_high,
            SecuritySeverity.MEDIUM: self.handle_medium,
            SecuritySeverity.LOW: self.handle_low
        }

    async def handle_incident(
        self,
        event_type: SecurityEventType,
        severity: SecuritySeverity,
        details: dict
    ):
        """å¤„ç†å®‰å…¨äº‹ä»¶"""
        # 1. è®°å½•äº‹ä»¶
        await self.log_incident(event_type, severity, details)

        # 2. è¯„ä¼°å½±å“
        impact = await self.assess_impact(event_type, details)

        # 3. æ ¹æ®ä¸¥é‡æ€§æ‰§è¡Œå“åº”
        handler = self.handlers.get(severity, self.handle_low)
        await handler(event_type, details, impact)

        # 4. ç”ŸæˆæŠ¥å‘Š
        report = await self.generate_incident_report(event_type, severity, impact)
        await self.send_report(report)

    async def handle_critical(self, event_type, details, impact):
        """å¤„ç†ä¸¥é‡äº‹ä»¶"""
        # 1. ç«‹å³åœæ­¢ç›¸å…³æ’ä»¶
        plugin_id = details.get("plugin_id")
        await self.suspend_plugin(plugin_id)

        # 2. é˜»æ­¢ç›¸å…³ç”¨æˆ·/IP
        if "user_id" in details:
            await self.block_user(details["user_id"])

        if "ip_address" in details:
            await self.block_ip(details["ip_address"])

        # 3. é€šçŸ¥å®‰å…¨å›¢é˜Ÿ
        await self.notify_security_team(event_type, details)

        # 4. ä¿ç•™è¯æ®
        await self.preserve_evidence(details)

    async def handle_high(self, event_type, details, impact):
        """å¤„ç†é«˜å±äº‹ä»¶"""
        # 1. æš‚åœæ’ä»¶
        await self.suspend_plugin(details.get("plugin_id"))

        # 2. é€šçŸ¥ç®¡ç†å‘˜
        await self.notify_admin(event_type, details)

        # 3. å¢åŠ ç›‘æ§é¢‘ç‡
        await self.increase_monitoring(details.get("plugin_id"))

    async def handle_medium(self, event_type, details, impact):
        """å¤„ç†ä¸­ç­‰é£é™©äº‹ä»¶"""
        # 1. å‘é€è­¦å‘Š
        await self.send_warning(event_type, details)

        # 2. è®°å½•æ—¥å¿—
        await self.log_warning(event_type, details)

    async def handle_low(self, event_type, details, impact):
        """å¤„ç†ä½é£é™©äº‹ä»¶"""
        # ä»…è®°å½•æ—¥å¿—
        await self.log_info(event_type, details)
```

### æ¢å¤æµç¨‹

```python
class IncidentRecovery:
    """äº‹ä»¶æ¢å¤"""

    async def restore_plugin(self, plugin_id: str, incident_report: dict):
        """æ¢å¤æ’ä»¶"""

        # 1. éªŒè¯å¨èƒå·²æ¶ˆé™¤
        if not await self.verify_threat_eliminated(plugin_id):
            raise RecoveryError("å¨èƒæœªæ¶ˆé™¤ï¼Œæ— æ³•æ¢å¤")

        # 2. éªŒè¯æ’ä»¶å®Œæ•´æ€§
        if not await self.verify_plugin_integrity(plugin_id):
            await self.reinstall_plugin(plugin_id)

        # 3. æ¢å¤é…ç½®ï¼ˆä»å¤‡ä»½ï¼‰
        await self.restore_config(plugin_id)

        # 4. å¯ç”¨æ’ä»¶ï¼ˆç›‘æ§æ¨¡å¼ï¼‰
        await self.enable_plugin(plugin_id, mode="monitored")

        # 5. æŒç»­ç›‘æ§
        await self.monitor_recovery(plugin_id)

        # 6. å¦‚æœç¨³å®šï¼Œåˆ‡æ¢åˆ°æ­£å¸¸æ¨¡å¼
        await asyncio.sleep(300)  # ç›‘æ§5åˆ†é’Ÿ
        if await self.is_stable(plugin_id):
            await self.enable_plugin(plugin_id, mode="normal")
```

---

## å®‰å…¨æ£€æŸ¥æ¸…å•

### æ’ä»¶å‘å¸ƒå‰æ£€æŸ¥

```markdown
## å®‰å…¨æ£€æŸ¥æ¸…å•

### ä»£ç å®‰å…¨
- [ ] æ‰€æœ‰ç”¨æˆ·è¾“å…¥éƒ½ç»è¿‡éªŒè¯å’Œæ¸…ç†
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢ SQL æ³¨å…¥
- [ ] æ²¡æœ‰ç¡¬ç¼–ç çš„å¯†é’¥æˆ–å‡­è¯
- [ ] æ•æ„Ÿæ•°æ®å·²åŠ å¯†å­˜å‚¨
- [ ] å®ç°äº†é€‚å½“çš„é”™è¯¯å¤„ç†ï¼ˆä¸æ³„éœ²ç³»ç»Ÿä¿¡æ¯ï¼‰

### æƒé™ç®¡ç†
- [ ] æ’ä»¶ä»…è¯·æ±‚å¿…è¦çš„æƒé™
- [ ] æ–‡ä»¶ç³»ç»Ÿè®¿é—®é™åˆ¶åœ¨æŒ‡å®šç›®å½•
- [ ] ç½‘ç»œè®¿é—®é™åˆ¶åœ¨å¿…è¦çš„åŸŸåå’Œç«¯å£
- [ ] ç¯å¢ƒå˜é‡è®¿é—®ç»è¿‡æˆæƒ

### æ•°æ®å®‰å…¨
- [ ] æ•æ„Ÿæ•°æ®åœ¨ä¼ è¾“ä¸­ä½¿ç”¨ HTTPS
- [ ] æ•æ„Ÿæ•°æ®åœ¨å­˜å‚¨ä¸­å·²åŠ å¯†
- [ ] æ—¥å¿—ä¸­ä¸åŒ…å«æ•æ„Ÿä¿¡æ¯
- [ ] å®ç°äº†æ•°æ®è„±æ•åŠŸèƒ½

### é€šä¿¡å®‰å…¨
- [ ] æ‰€æœ‰ç½‘ç»œé€šä¿¡ä½¿ç”¨ TLS
- [ ] API è°ƒç”¨ä½¿ç”¨ç­¾åéªŒè¯
- [ ] å®ç°äº†é˜²é‡æ”¾æ”»å‡»æœºåˆ¶

### ä¾èµ–å®‰å…¨
- [ ] æ‰€æœ‰ä¾èµ–åŒ…ç»è¿‡å®‰å…¨å®¡è®¡
- [ ] è¿è¡Œäº†æ¼æ´æ‰«æå·¥å…·
- [ ] ä¾èµ–ç‰ˆæœ¬å›ºå®šä¸”ç»è¿‡æµ‹è¯•
- [ ] å®šæœŸæ›´æ–°ä¾èµ–åˆ°å®‰å…¨ç‰ˆæœ¬

### ç›‘æ§å’Œæ—¥å¿—
- [ ] è®°å½•å…³é”®æ“ä½œæ—¥å¿—
- [ ] å®ç°äº†å®‰å…¨äº‹ä»¶æ£€æµ‹
- [ ] é…ç½®äº†å¼‚å¸¸è¡Œä¸ºå‘Šè­¦
- [ ] æ—¥å¿—å®šæœŸå¤‡ä»½å’Œå®¡è®¡

### æµ‹è¯•
- [ ] ç¼–å†™äº†å®‰å…¨å•å…ƒæµ‹è¯•
- [ ] è¿›è¡Œäº†æ¸—é€æµ‹è¯•
- [ ] æµ‹è¯•äº†é”™è¯¯å’Œå¼‚å¸¸æƒ…å†µ
- [ ] éªŒè¯äº†æƒé™å¼ºåˆ¶æ‰§è¡Œ
```

---

## å‚è€ƒèµ„æ–™

### å®‰å…¨æ ‡å‡†
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [CWE/SANS Top 25](https://cwe.mitre.org/top25/)
- [Python å®‰å…¨æœ€ä½³å®è·µ](https://docs.python.org/3/library/security_warnings.html)

### å·¥å…·
- [Bandit - Python å®‰å…¨åˆ†æå™¨](https://github.com/PyCQA/bandit)
- [Safety - ä¾èµ–æ¼æ´æ‰«æ](https://github.com/pyupio/safety)
- [PyT - é™æ€åˆ†æå·¥å…·](https://github.com/PyCQA/pylint)

### ç›¸å…³æ–‡æ¡£
- [[ClawdBotå®Œæ•´æŒ‡å—]] - ClawdBot å®Œæ•´ä½¿ç”¨æŒ‡å—
- [[æ’ä»¶å¼€å‘æŒ‡å—]] - æ’ä»¶å¼€å‘æ•™ç¨‹
- [[æ€§èƒ½ä¼˜åŒ–å®è·µ]] - æ€§èƒ½ä¼˜åŒ–æŒ‡å—

---

*åˆ›å»ºæ—¶é—´: 2026-01-31*
*æœ€åæ›´æ–°: 2026-01-31*
*åˆ†ç±»: 3 Resources*
