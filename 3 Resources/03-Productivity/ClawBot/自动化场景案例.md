---
title: è‡ªåŠ¨åŒ–åœºæ™¯æ¡ˆä¾‹
status: active
priority: high
tags: [clawdbot, automation, cases, examples]
aliases: [è‡ªåŠ¨åŒ–æ¡ˆä¾‹, å®æˆ˜æ¡ˆä¾‹]
created: 2026-01-31
modified: 2026-01-31
---

# è‡ªåŠ¨åŒ–åœºæ™¯æ¡ˆä¾‹

> æœ¬æ–‡æ¡£æ”¶é›†äº† ClawdBot çš„å®é™…åº”ç”¨åœºæ™¯å’Œå®Œæ•´å®ç°æ¡ˆä¾‹ï¼Œå¸®åŠ©æ‚¨å¿«é€Ÿç†è§£å¦‚ä½•è§£å†³å®é™…é—®é¢˜ã€‚

## ğŸ“‹ ç›®å½•

- [ç”µå•†è‡ªåŠ¨åŒ–](#ç”µå•†è‡ªåŠ¨åŒ–)
- [è¿è¥æ•°æ®åˆ†æ](#è¿è¥æ•°æ®åˆ†æ)
- [å®¢æˆ·æœåŠ¡è‡ªåŠ¨åŒ–](#å®¢æˆ·æœåŠ¡è‡ªåŠ¨åŒ–)
- [ç¤¾äº¤åª’ä½“ç®¡ç†](#ç¤¾äº¤åª’ä½“ç®¡ç†)
- [æ•°æ®å¤‡ä»½ä¸åŒæ­¥](#æ•°æ®å¤‡ä»½ä¸åŒæ­¥)
- [è´¢åŠ¡æŠ¥è¡¨è‡ªåŠ¨åŒ–](#è´¢åŠ¡æŠ¥è¡¨è‡ªåŠ¨åŒ–)
- [é¡¹ç›®ç®¡ç†è‡ªåŠ¨åŒ–](#é¡¹ç›®ç®¡ç†è‡ªåŠ¨åŒ–)

---

## ç”µå•†è‡ªåŠ¨åŒ–

### æ¡ˆä¾‹1ï¼šç«å“ä»·æ ¼ç›‘æ§

**åœºæ™¯æè¿°ï¼š**
è‡ªåŠ¨ç›‘æ§ç«äº‰å¯¹æ‰‹çš„å•†å“ä»·æ ¼å˜åŒ–ï¼Œå½“ä»·æ ¼ä½äºè®¾å®šé˜ˆå€¼æ—¶å‘é€å‘Šè­¦ã€‚

```python
# examples/ecommerce/price_monitor.py
from clawdbot import Clawdbot, Task
import asyncio
from datetime import datetime

class PriceMonitor:
    def __init__(self, bot: Clawdbot):
        self.bot = bot
        self.products = [
            {
                "id": "P001",
                "name": "é«˜ç«¯è€³æœº",
                "competitor_url": "https://competitor.com/product/earbuds",
                "threshold": 299.0  # ä½äºæ­¤ä»·æ ¼å‘Šè­¦
            },
            {
                "id": "P002",
                "name": "æ™ºèƒ½æ‰‹è¡¨",
                "competitor_url": "https://competitor.com/product/watch",
                "threshold": 599.0
            }
        ]

    async def monitor_prices(self):
        """ç›‘æ§æ‰€æœ‰äº§å“ä»·æ ¼"""
        results = []

        for product in self.products:
            try:
                # æŠ“å–ç«äº‰å¯¹æ‰‹ä»·æ ¼
                price = await self.scrape_competitor_price(product["competitor_url"])

                result = {
                    "product_id": product["id"],
                    "product_name": product["name"],
                    "competitor_price": price,
                    "threshold": product["threshold"],
                    "is_below_threshold": price < product["threshold"],
                    "timestamp": datetime.now().isoformat()
                }

                results.append(result)

                # å¦‚æœä»·æ ¼ä½äºé˜ˆå€¼ï¼Œå‘é€å‘Šè­¦
                if price < product["threshold"]:
                    await self.send_price_alert(result)

            except Exception as e:
                print(f"ç›‘æ§å¤±è´¥ {product['name']}: {e}")

        return results

    async def scrape_competitor_price(self, url: str) -> float:
        """æŠ“å–ç«äº‰å¯¹æ‰‹ä»·æ ¼"""
        task = Task(
            type="web_scrape",
            params={
                "url": url,
                "selectors": {
                    "price": ".product-price",
                    "currency": ".currency-symbol"
                },
                "timeout": 30
            }
        )

        result = await self.bot.execute(task)

        # æå–ä»·æ ¼æ•°å€¼
        price_text = result.data["price"]
        price = float(price_text.replace("Â¥", "").replace(",", ""))

        return price

    async def send_price_alert(self, price_info: dict):
        """å‘é€ä»·æ ¼å‘Šè­¦"""
        alert_task = Task(
            type="send_email",
            params={
                "to": ["pricing@company.com", "marketing@company.com"],
                "subject": f"ğŸš¨ ä»·æ ¼å‘Šè­¦: {price_info['product_name']}",
                "body": f"""
                ç«å“ä»·æ ¼ç›‘æµ‹å‘Šè­¦

                äº§å“: {price_info['product_name']}
                å½“å‰ç«å“ä»·æ ¼: Â¥{price_info['competitor_price']}
                è®¾å®šé˜ˆå€¼: Â¥{price_info['threshold']}
                ä»·æ ¼å·®: Â¥{price_info['threshold'] - price_info['competitor_price']}

                ç›‘æµ‹æ—¶é—´: {price_info['timestamp']}

                è¯·åŠæ—¶è¯„ä¼°æ˜¯å¦éœ€è¦è°ƒæ•´ä»·æ ¼ç­–ç•¥ï¼
                """,
                "priority": "high"
            }
        )

        await self.bot.execute(alert_task)

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    bot = Clawdbot(config="config.yaml")
    monitor = PriceMonitor(bot)

    # æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡ç›‘æ§
    while True:
        results = await monitor.monitor_prices()
        print(f"ç›‘æ§å®Œæˆï¼Œæ£€æŸ¥äº† {len(results)} ä¸ªäº§å“")

        # ç­‰å¾…1å°æ—¶
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
```

**å·¥ä½œæµé…ç½®ï¼š**

```yaml
# workflows/price_monitoring.yml
name: ç«å“ä»·æ ¼ç›‘æ§
schedule:
  cron: "0 * * * *"  # æ¯å°æ—¶
  timezone: "Asia/Shanghai"

steps:
  - name: è·å–äº§å“åˆ—è¡¨
    type: database_query
    params:
      query: "SELECT * FROM products WHERE monitoring_enabled = true"

  - name: æŠ“å–ç«å“ä»·æ ¼
    type: parallel_scrape
    params:
      max_concurrency: 5
      timeout_per_task: 30

  - name: å¯¹æ¯”ä»·æ ¼
    type: transform
    params:
      script: "compare_prices.js"

  - name: å‘é€å‘Šè­¦
    type: conditional_action
    params:
      condition: "price < threshold"
      action: "send_email"
```

---

### æ¡ˆä¾‹2ï¼šè®¢å•è‡ªåŠ¨å¤„ç†

```python
# examples/ecommerce/order_processing.py
from clawdbot import Clawdbot, Task

class OrderProcessor:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def process_new_orders(self):
        """å¤„ç†æ–°è®¢å•"""

        # 1. è·å–å¾…å¤„ç†è®¢å•
        orders = await self.fetch_pending_orders()

        for order in orders:
            try:
                # 2. éªŒè¯åº“å­˜
                stock_available = await self.check_inventory(order["items"])

                if stock_available:
                    # 3. æ‰£å‡åº“å­˜
                    await self.deduct_inventory(order["items"])

                    # 4. ç”Ÿæˆå‘è´§å•
                    shipping_info = await self.create_shipping_order(order)

                    # 5. å‘é€ç¡®è®¤é‚®ä»¶
                    await self.send_order_confirmation(order, shipping_info)

                    # 6. æ›´æ–°è®¢å•çŠ¶æ€
                    await self.update_order_status(order["id"], "processing")

                else:
                    # åº“å­˜ä¸è¶³
                    await self.handle_out_of_stock(order)

            except Exception as e:
                await self.handle_processing_error(order, e)

    async def fetch_pending_orders(self):
        """è·å–å¾…å¤„ç†è®¢å•"""
        task = Task(
            type="api_call",
            params={
                "method": "GET",
                "url": "/api/orders",
                "params": {
                    "status": "pending",
                    "limit": 50
                }
            }
        )

        result = await self.bot.execute(task)
        return result.data

    async def check_inventory(self, items: list) -> bool:
        """æ£€æŸ¥åº“å­˜"""
        for item in items:
            stock = await self.get_stock(item["product_id"])
            if stock < item["quantity"]:
                return False
        return True

    async def create_shipping_order(self, order: dict) -> dict:
        """åˆ›å»ºå‘è´§å•"""
        task = Task(
            type="form_submit",
            params={
                "url": "https://shipping.partner.com/api/create",
                "form_data": {
                    "recipient_name": order["customer_name"],
                    "recipient_address": order["shipping_address"],
                    "recipient_phone": order["phone"],
                    "packages": order["items"],
                    "service_type": "standard"
                }
            }
        )

        result = await self.bot.execute(task)
        return result.data

    async def send_order_confirmation(self, order: dict, shipping_info: dict):
        """å‘é€è®¢å•ç¡®è®¤é‚®ä»¶"""
        task = Task(
            type="send_email",
            params={
                "to": [order["customer_email"]],
                "template": "order_confirmation",
                "data": {
                    "order_id": order["id"],
                    "items": order["items"],
                    "total": order["total"],
                    "shipping_tracking": shipping_info["tracking_number"]
                }
            }
        )

        await self.bot.execute(task)
```

---

## è¿è¥æ•°æ®åˆ†æ

### æ¡ˆä¾‹3ï¼šç¤¾äº¤åª’ä½“æ•°æ®é‡‡é›†ä¸åˆ†æ

```python
# examples/analytics/social_media_analyzer.py
from clawdbot import Clawdbot, Task
import pandas as pd
from datetime import datetime, timedelta

class SocialMediaAnalyzer:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def daily_analysis(self):
        """æ¯æ—¥æ•°æ®åˆ†æ"""

        # 1. é‡‡é›†æ•°æ®
        data = await self.collect_data()

        # 2. æ•°æ®æ¸…æ´—
        clean_data = await self.clean_data(data)

        # 3. ç”ŸæˆæŠ¥å‘Š
        report = await self.generate_report(clean_data)

        # 4. å‘é€æŠ¥å‘Š
        await self.send_report(report)

    async def collect_data(self):
        """é‡‡é›†å¤šå¹³å°æ•°æ®"""
        platforms = ["twitter", "weibo", "wechat"]
        all_data = []

        for platform in platforms:
            # é‡‡é›†æ•°æ®
            task = Task(
                type="api_call",
                params={
                    "method": "GET",
                    "url": f"/api/{platform}/analytics",
                    "params": {
                        "start_date": (datetime.now() - timedelta(days=1)).isoformat(),
                        "end_date": datetime.now().isoformat()
                    }
                }
            )

            result = await self.bot.execute(task)
            all_data.extend(result.data)

        return all_data

    async def generate_report(self, data: list):
        """ç”Ÿæˆåˆ†ææŠ¥å‘Š"""

        # è½¬æ¢ä¸º DataFrame
        df = pd.DataFrame(data)

        # è®¡ç®—å…³é”®æŒ‡æ ‡
        metrics = {
            "total_posts": len(df),
            "total_engagement": df["engagement"].sum(),
            "avg_engagement_rate": df["engagement_rate"].mean(),
            "top_posts": df.nlargest(5, "engagement")[["platform", "content", "engagement"]].to_dict("records"),
            "platform_distribution": df.groupby("platform")["engagement"].sum().to_dict()
        }

        # ç”Ÿæˆå›¾è¡¨
        charts = await self.generate_charts(df)

        return {
            "date": datetime.now().strftime("%Y-%m-%d"),
            "metrics": metrics,
            "charts": charts,
            "insights": await self.generate_insights(metrics)
        }

    async def generate_insights(self, metrics: dict) -> list:
        """ç”Ÿæˆæ´å¯Ÿ"""
        insights = []

        # åŸºäºæŒ‡æ ‡çš„æ´å¯Ÿ
        if metrics["avg_engagement_rate"] > 0.05:
            insights.append("äº’åŠ¨ç‡è¡¨ç°ä¼˜å¼‚ï¼Œå†…å®¹ç­–ç•¥æœ‰æ•ˆ")

        best_platform = max(metrics["platform_distribution"], key=metrics["platform_distribution"].get)
        insights.append(f"{best_platform} å¹³å°è¡¨ç°æœ€ä½³ï¼Œå»ºè®®å¢åŠ æŠ•å…¥")

        return insights

    async def send_report(self, report: dict):
        """å‘é€æŠ¥å‘Š"""
        task = Task(
            type="send_email",
            params={
                "to": ["analytics@company.com", "marketing@company.com"],
                "subject": f"ğŸ“Š ç¤¾äº¤åª’ä½“æ•°æ®æ—¥æŠ¥ - {report['date']}",
                "body": f"""
                ç¤¾äº¤åª’ä½“æ•°æ®åˆ†ææŠ¥å‘Š

                ğŸ“ˆ æ ¸å¿ƒæŒ‡æ ‡ï¼š
                - æ€»å‘å¸ƒæ•°ï¼š{report['metrics']['total_posts']}
                - æ€»äº’åŠ¨é‡ï¼š{report['metrics']['total_engagement']}
                - å¹³å‡äº’åŠ¨ç‡ï¼š{report['metrics']['avg_engagement_rate']:.2%}

                ğŸ”¥ çƒ­é—¨å†…å®¹ï¼š
                {self.format_top_posts(report['metrics']['top_posts'])}

                ğŸ’¡ æ•°æ®æ´å¯Ÿï¼š
                {chr(10).join(f'- {insight}' for insight in report['insights'])}
                """,
                "attachments": report["charts"]
            }
        )

        await self.bot.execute(task)
```

---

## å®¢æˆ·æœåŠ¡è‡ªåŠ¨åŒ–

### æ¡ˆä¾‹4ï¼šæ™ºèƒ½å®¢æœå·¥å•åˆ†é…

```python
# examples/customer_service/ticket_routing.py
from clawdbot import Clawdbot, Task
import re

class TicketRouter:
    def __init__(self, bot: Clawdbot):
        self.bot = bot
        self.routing_rules = {
            "æŠ€æœ¯æ”¯æŒ": [
                r"æ•…éšœ|é”™è¯¯|bug|æ— æ³•|ç™»å½•|å®‰è£…|é…ç½®"
            ],
            "è´¦å•é—®é¢˜": [
                r"è´¦å•|æ”¯ä»˜|å‘ç¥¨|é€€æ¬¾|æ‰£è´¹"
            ],
            "åŠŸèƒ½å»ºè®®": [
                r"å»ºè®®|å¸Œæœ›|æ–°å¢|æ”¹è¿›|éœ€æ±‚"
            ],
            "æŠ•è¯‰": [
                r"æŠ•è¯‰|ä¸æ»¡|ç³Ÿç³•|å¤±æœ›|æ…¢"
            ]
        }

    async def route_new_tickets(self):
        """åˆ†é…æ–°å·¥å•"""

        # è·å–æœªåˆ†é…çš„å·¥å•
        tickets = await self.fetch_unassigned_tickets()

        for ticket in tickets:
            # åˆ†æå·¥å•ç±»å‹
            category = self.classify_ticket(ticket)

            # åˆ†é…ç»™å¯¹åº”å›¢é˜Ÿ
            team = self.get_team_for_category(category)

            # æ›´æ–°å·¥å•
            await self.assign_ticket(ticket["id"], team, category)

            # é€šçŸ¥å›¢é˜Ÿ
            await self.notify_team(team, ticket)

    def classify_ticket(self, ticket: dict) -> str:
        """åˆ†ç±»å·¥å•"""
        text = f"{ticket['subject']} {ticket['description']}"

        for category, patterns in self.routing_rules.items():
            for pattern in patterns:
                if re.search(pattern, text, re.IGNORECASE):
                    return category

        return "ä¸€èˆ¬å’¨è¯¢"

    def get_team_for_category(self, category: str) -> str:
        """è·å–è´Ÿè´£å›¢é˜Ÿ"""
        team_mapping = {
            "æŠ€æœ¯æ”¯æŒ": "tech_support",
            "è´¦å•é—®é¢˜": "billing",
            "åŠŸèƒ½å»ºè®®": "product",
            "æŠ•è¯‰": "escalation",
            "ä¸€èˆ¬å’¨è¯¢": "general_support"
        }

        return team_mapping.get(category, "general_support")

    async def assign_ticket(self, ticket_id: str, team: str, category: str):
        """åˆ†é…å·¥å•"""
        task = Task(
            type="api_call",
            params={
                "method": "PUT",
                "url": f"/api/tickets/{ticket_id}",
                "data": {
                    "assigned_team": team,
                    "category": category,
                    "status": "assigned"
                }
            }
        )

        await self.bot.execute(task)

    async def notify_team(self, team: str, ticket: dict):
        """é€šçŸ¥å›¢é˜Ÿ"""
        team_email = self.get_team_email(team)

        task = Task(
            type="send_email",
            params={
                "to": [team_email],
                "subject": f"ğŸ« æ–°å·¥å•åˆ†é…: {ticket['subject']}",
                "body": f"""
                æ–°å·¥å•å·²åˆ†é…åˆ°æ‚¨çš„å›¢é˜Ÿ

                å·¥å•ç¼–å·ï¼š{ticket['id']}
                ä¸»é¢˜ï¼š{ticket['subject']}
                ä¼˜å…ˆçº§ï¼š{ticket['priority']}
                æäº¤æ—¶é—´ï¼š{ticket['created_at']}

                æè¿°ï¼š
                {ticket['description']}

                è¯·åŠæ—¶å¤„ç†ï¼
                """
            }
        )

        await self.bot.execute(task)
```

---

## ç¤¾äº¤åª’ä½“ç®¡ç†

### æ¡ˆä¾‹5ï¼šå†…å®¹è‡ªåŠ¨å‘å¸ƒ

```python
# examples/social_media/auto_publisher.py
from clawdbot import Clawdbot, Task
from datetime import datetime, timedelta

class ContentPublisher:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def publish_scheduled_content(self):
        """å‘å¸ƒå®šæ—¶å†…å®¹"""

        # è·å–å¾…å‘å¸ƒå†…å®¹
        content = await self.fetch_scheduled_content()

        for item in content:
            if self.should_publish(item):
                try:
                    # å‘å¸ƒåˆ°å„ä¸ªå¹³å°
                    results = await self.publish_to_platforms(item)

                    # è®°å½•å‘å¸ƒç»“æœ
                    await self.log_publication(item, results)

                    # æ›´æ–°å†…å®¹çŠ¶æ€
                    await self.mark_as_published(item["id"])

                except Exception as e:
                    await self.handle_publishing_error(item, e)

    async def publish_to_platforms(self, content: dict):
        """å‘å¸ƒåˆ°å¤šä¸ªå¹³å°"""
        platforms = content.get("platforms", ["twitter", "weibo"])
        results = {}

        for platform in platforms:
            task = Task(
                type="social_media_post",
                params={
                    "platform": platform,
                    "content": self.format_content(platform, content),
                    "media": content.get("media", []),
                    "scheduled_at": content.get("scheduled_at")
                }
            )

            result = await self.bot.execute(task)
            results[platform] = {
                "success": result.success,
                "post_id": result.data.get("post_id"),
                "url": result.data.get("post_url")
            }

        return results

    def format_content(self, platform: str, content: dict) -> str:
        """æ ¼å¼åŒ–ä¸åŒå¹³å°çš„å†…å®¹"""
        text = content["text"]

        if platform == "twitter":
            # Twitter é™åˆ¶ 280 å­—ç¬¦
            if len(text) > 280:
                text = text[:277] + "..."
            # æ·»åŠ è¯é¢˜æ ‡ç­¾
            text += " " + " ".join(content.get("hashtags", []))[:100]

        elif platform == "weibo":
            # å¾®åšé™åˆ¶ 140 å­—ï¼ˆä¸­æ–‡ï¼‰
            pass

        elif platform == "linkedin":
            # LinkedIn å¯ä»¥æ›´é•¿
            text = f"{text}\n\n{content.get('link', '')}"

        return text
```

---

## æ•°æ®å¤‡ä»½ä¸åŒæ­¥

### æ¡ˆä¾‹6ï¼šè‡ªåŠ¨åŒ–æ•°æ®å¤‡ä»½

```python
# examples/backup/auto_backup.py
from clawdbot import Clawdbot, Task
from datetime import datetime

class AutoBackup:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def perform_backup(self):
        """æ‰§è¡Œå¤‡ä»½"""

        # 1. å¤‡ä»½æ•°æ®åº“
        db_backup = await self.backup_database()

        # 2. å¤‡ä»½æ–‡ä»¶
        file_backup = await self.backup_files()

        # 3. ä¸Šä¼ åˆ°äº‘å­˜å‚¨
        await self.upload_to_cloud(db_backup, file_backup)

        # 4. æ¸…ç†æ—§å¤‡ä»½
        await self.cleanup_old_backups()

    async def backup_database(self) -> str:
        """å¤‡ä»½æ•°æ®åº“"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"backup/db_backup_{timestamp}.sql"

        task = Task(
            type="database_dump",
            params={
                "database": "production",
                "output_file": backup_file,
                "compression": "gzip"
            }
        )

        result = await self.bot.execute(task)
        return result.data["backup_file"]

    async def backup_files(self) -> str:
        """å¤‡ä»½æ–‡ä»¶"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"backup/files_backup_{timestamp}.tar.gz"

        task = Task(
            type="archive_files",
            params={
                "source_dir": "/app/data",
                "output_file": backup_file,
                "exclude": ["*.log", "*.tmp", "cache/*"]
            }
        )

        result = await self.bot.execute(task)
        return result.data["archive_file"]

    async def upload_to_cloud(self, db_backup: str, file_backup: str):
        """ä¸Šä¼ åˆ°äº‘å­˜å‚¨"""
        for backup_file in [db_backup, file_backup]:
            task = Task(
                type="cloud_upload",
                params={
                    "file": backup_file,
                    "bucket": "company-backups",
                    "path": f"daily/{datetime.now().strftime('%Y/%m/%d')}/{backup_file.split('/')[-1]}"
                }
            )

            await self.bot.execute(task)

    async def cleanup_old_backups(self):
        """æ¸…ç†æ—§å¤‡ä»½ï¼ˆä¿ç•™æœ€è¿‘7å¤©ï¼‰"""
        task = Task(
            type="cloud_cleanup",
            params={
                "bucket": "company-backups",
                "pattern": "daily/**/*",
                "older_than_days": 7
            }
        )

        await self.bot.execute(task)
```

---

## è´¢åŠ¡æŠ¥è¡¨è‡ªåŠ¨åŒ–

### æ¡ˆä¾‹7ï¼šæœˆåº¦è´¢åŠ¡æŠ¥å‘Šç”Ÿæˆ

```python
# examples/finance/monthly_report.py
from clawdbot import Clawdbot, Task
import pandas as pd
from datetime import datetime, timedelta

class MonthlyFinanceReport:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def generate_report(self, month: int, year: int):
        """ç”Ÿæˆæœˆåº¦æŠ¥å‘Š"""

        # 1. æ”¶é›†è´¢åŠ¡æ•°æ®
        financial_data = await self.collect_financial_data(month, year)

        # 2. è®¡ç®—è´¢åŠ¡æŒ‡æ ‡
        metrics = self.calculate_metrics(financial_data)

        # 3. ç”Ÿæˆå›¾è¡¨
        charts = await self.generate_charts(financial_data)

        # 4. ç”Ÿæˆ PDF æŠ¥å‘Š
        pdf_file = await self.generate_pdf_report(metrics, charts)

        # 5. å‘é€æŠ¥å‘Š
        await self.send_report(pdf_file, month, year)

    async def collect_financial_data(self, month: int, year: int):
        """æ”¶é›†è´¢åŠ¡æ•°æ®"""
        start_date = datetime(year, month, 1).isoformat()
        end_date = (datetime(year, month, 1) + timedelta(days=32)).replace(day=1).isoformat()

        # æ”¶å…¥æ•°æ®
        revenue_task = Task(
            type="database_query",
            params={
                "query": f"""
                    SELECT date, amount, category
                    FROM revenue
                    WHERE date >= '{start_date}' AND date < '{end_date}'
                """
            }
        )

        # æ”¯å‡ºæ•°æ®
        expense_task = Task(
            type="database_query",
            params={
                "query": f"""
                    SELECT date, amount, category
                    FROM expenses
                    WHERE date >= '{start_date}' AND date < '{end_date}'
                """
            }
        )

        # å¹¶è¡Œæ‰§è¡Œ
        revenue = await self.bot.execute(revenue_task)
        expenses = await self.bot.execute(expense_task)

        return {
            "revenue": revenue.data,
            "expenses": expenses.data
        }

    def calculate_metrics(self, data: dict) -> dict:
        """è®¡ç®—è´¢åŠ¡æŒ‡æ ‡"""
        revenue_df = pd.DataFrame(data["revenue"])
        expense_df = pd.DataFrame(data["expenses"])

        total_revenue = revenue_df["amount"].sum()
        total_expenses = expense_df["amount"].sum()
        net_profit = total_revenue - total_expenses
        profit_margin = (net_profit / total_revenue) * 100 if total_revenue > 0 else 0

        revenue_by_category = revenue_df.groupby("category")["amount"].sum().to_dict()
        expense_by_category = expense_df.groupby("category")["amount"].sum().to_dict()

        return {
            "total_revenue": total_revenue,
            "total_expenses": total_expenses,
            "net_profit": net_profit,
            "profit_margin": profit_margin,
            "revenue_by_category": revenue_by_category,
            "expense_by_category": expense_by_category
        }
```

---

## é¡¹ç›®ç®¡ç†è‡ªåŠ¨åŒ–

### æ¡ˆä¾‹8ï¼šé¡¹ç›®è¿›åº¦è‡ªåŠ¨è·Ÿè¸ª

```python
# examples/project_management/progress_tracker.py
from clawdbot import Clawdbot, Task
from datetime import datetime, timedelta

class ProjectProgressTracker:
    def __init__(self, bot: Clawdbot):
        self.bot = bot

    async def track_progress(self):
        """è·Ÿè¸ªé¡¹ç›®è¿›åº¦"""

        # è·å–æ‰€æœ‰æ´»è·ƒé¡¹ç›®
        projects = await self.fetch_active_projects()

        for project in projects:
            # è®¡ç®—è¿›åº¦
            progress = await self.calculate_project_progress(project)

            # æ£€æŸ¥é‡Œç¨‹ç¢‘
            milestones = await self.check_milestones(project, progress)

            # æ£€æŸ¥é£é™©
            risks = await self.assess_risks(project, progress)

            # å‘é€è¿›åº¦æ›´æ–°
            if self.should_notify(project, progress, milestones, risks):
                await self.send_progress_update(project, progress, milestones, risks)

    async def calculate_project_progress(self, project: dict) -> dict:
        """è®¡ç®—é¡¹ç›®è¿›åº¦"""
        tasks = await self.fetch_project_tasks(project["id"])

        completed_tasks = [t for t in tasks if t["status"] == "completed"]
        total_tasks = len(tasks)

        progress_percentage = (len(completed_tasks) / total_tasks * 100) if total_tasks > 0 else 0

        # è®¡ç®—é¢„ç®—ä½¿ç”¨
        spent = project.get("budget_spent", 0)
        total_budget = project.get("budget", 1)
        budget_usage = (spent / total_budget * 100) if total_budget > 0 else 0

        return {
            "percentage": progress_percentage,
            "completed_tasks": len(completed_tasks),
            "total_tasks": total_tasks,
            "budget_usage": budget_usage,
            "on_schedule": self.check_if_on_schedule(project, tasks)
        }

    async def check_milestones(self, project: dict, progress: dict) -> list:
        """æ£€æŸ¥é‡Œç¨‹ç¢‘"""
        milestones = await self.fetch_project_milestones(project["id"])
        completed_milestones = []

        for milestone in milestones:
            if progress["percentage"] >= milestone["percentage"] and not milestone["completed"]:
                completed_milestones.append(milestone)

        return completed_milestones

    async def assess_risks(self, project: dict, progress: dict) -> list:
        """è¯„ä¼°é¡¹ç›®é£é™©"""
        risks = []

        # è¿›åº¦å»¶è¿Ÿé£é™©
        if not progress["on_schedule"]:
            risks.append({
                "type": "schedule_delay",
                "severity": "high",
                "description": "é¡¹ç›®è¿›åº¦è½åäºè®¡åˆ’"
            })

        # é¢„ç®—è¶…æ”¯é£é™©
        if progress["budget_usage"] > 90:
            risks.append({
                "type": "budget_overrun",
                "severity": "high" if progress["budget_usage"] > 100 else "medium",
                "description": f"é¢„ç®—å·²ä½¿ç”¨ {progress['budget_usage']:.1f}%"
            })

        # é€¾æœŸä»»åŠ¡é£é™©
        overdue_tasks = await self.get_overdue_tasks(project["id"])
        if overdue_tasks:
            risks.append({
                "type": "overdue_tasks",
                "severity": "medium",
                "description": f"{len(overdue_tasks)} ä¸ªä»»åŠ¡å·²é€¾æœŸ",
                "details": overdue_tasks
            })

        return risks

    async def send_progress_update(self, project: dict, progress: dict, milestones: list, risks: list):
        """å‘é€è¿›åº¦æ›´æ–°"""
        task = Task(
            type="send_email",
            params={
                "to": project["stakeholders"],
                "subject": f"ğŸ“Š é¡¹ç›®è¿›åº¦æ›´æ–°: {project['name']}",
                "template": "project_progress",
                "data": {
                    "project_name": project["name"],
                    "progress": progress,
                    "milestones": milestones,
                    "risks": risks
                }
            }
        )

        await self.bot.execute(task)
```

---

## æ€»ç»“

### åœºæ™¯åˆ†ç±»çŸ©é˜µ

| åœºæ™¯ç±»å‹ | å¤æ‚åº¦ | å¸¸ç”¨ç»„ä»¶ | å…¸å‹ä»»åŠ¡ |
|---------|-------|---------|---------|
| ç”µå•†è‡ªåŠ¨åŒ– | ä¸­ç­‰ | ç½‘é¡µæŠ“å–ã€APIè°ƒç”¨ã€é‚®ä»¶ | ä»·æ ¼ç›‘æ§ã€è®¢å•å¤„ç† |
| æ•°æ®åˆ†æ | è¾ƒé«˜ | æ•°æ®é‡‡é›†ã€æ•°æ®å¤„ç†ã€æŠ¥å‘Šç”Ÿæˆ | æ•°æ®é‡‡é›†ã€åˆ†ææŠ¥å‘Š |
| å®¢æˆ·æœåŠ¡ | ä¸­ç­‰ | è¡¨å•å¤„ç†ã€è§„åˆ™å¼•æ“ã€é€šçŸ¥ | å·¥å•åˆ†é…ã€è‡ªåŠ¨å›å¤ |
| ç¤¾äº¤åª’ä½“ | ä¸­ç­‰ | APIè°ƒç”¨ã€å†…å®¹å‘å¸ƒã€å®šæ—¶ä»»åŠ¡ | å†…å®¹å‘å¸ƒã€æ•°æ®é‡‡é›† |
| å¤‡ä»½åŒæ­¥ | è¾ƒä½ | æ•°æ®åº“æ“ä½œã€æ–‡ä»¶æ“ä½œã€äº‘å­˜å‚¨ | å®šæ—¶å¤‡ä»½ã€æ•°æ®åŒæ­¥ |
| è´¢åŠ¡æŠ¥å‘Š | è¾ƒé«˜ | æ•°æ®æŸ¥è¯¢ã€è®¡ç®—ã€PDFç”Ÿæˆ | æŠ¥è¡¨ç”Ÿæˆã€æ•°æ®åˆ†æ |
| é¡¹ç›®ç®¡ç† | ä¸­ç­‰ | æ•°æ®æŸ¥è¯¢ã€ä»»åŠ¡ç®¡ç†ã€é£é™©è¯„ä¼° | è¿›åº¦è·Ÿè¸ªã€é£é™©è¯„ä¼° |

### å¼€å‘å»ºè®®

1. **ä»å°åˆ°å¤§**ï¼šå…ˆå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œå†é€æ­¥å®Œå–„
2. **æ¨¡å—åŒ–è®¾è®¡**ï¼šå°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå¯å¤ç”¨çš„å°æ¨¡å—
3. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
4. **æ—¥å¿—è®°å½•**ï¼šè¯¦ç»†çš„æ—¥å¿—ä¾¿äºè°ƒè¯•å’Œç»´æŠ¤
5. **æµ‹è¯•éªŒè¯**ï¼šå……åˆ†æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µ

---

*åˆ›å»ºæ—¶é—´: 2026-01-31*
*æœ€åæ›´æ–°: 2026-01-31*
*åˆ†ç±»: 3 Resources*
